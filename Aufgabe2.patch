diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/doc/devenv.dox Aufgabe2/doc/devenv.dox
--- Aufgabe1_Lsg/doc/devenv.dox	2013-04-27 09:04:40.456090200 +0200
+++ Aufgabe2/doc/devenv.dox	2013-05-02 00:19:09.308787900 +0200
@@ -120,6 +120,108 @@
  * die in leicht abgewandelter Form auch unter Linux funktioniert.
  * 
  * 
+ * \section devenv_sec5 Patch als Vorgabe
+ * Einige Vorgaben werden als Patchdatei angeboten. Diese kommen mit Hilfe von patch in das 
+ * vorhandene System eingebunden werden. In diesem Beispiel wird von einer bestehenden 
+ * Implementation der ersten Aufgabe ausgegangen. Die Vorgabe der zweiten soll gepatcht werden.
+ * Der Patch liegt bereits im Hauptverzeichnis von OOStuBS. Auch die Konsole befindet sich 
+ * in dem Ordner.
+ * \verbatim
+patch -p1 < Aufgabe2.patch
+\endverbatim
+ * 
+ * Im Anschluss sollten die Dateien der Vorgaben und die Änderungen der Vorgaben vorhanden sein.
+ * 
+ * Sind Binärdateien, wie Bilder, in den Änderungen erhalten, so werden diese als extra Paket 
+ * angeboten, die dann manuell in den richtigen Ordner kopiert werden müssen.
+ * 
+ * \subsection devenv_sec5_1 Fehler beim Patch
+ * Es kann vorkommen, dass patch nicht alle Stellen zum Ändern finden kann oder dass andere 
+ * Konflikte auftreten. Diese müssen dann manuell behoben werden. Nehmen wir folgendes Beispiel
+ * an:
+ * \verbatim
+ubuntu@ubuntuPC:/data/oostubs/oostubs$ patch -p1 < Aufgabe2.patch 
+patching file doc/task1.dox
+patching file doc/task2.dox
+patching file include/device/keyboard.h
+patching file include/device/panic.h
+patching file include/guard/gate.h
+patching file include/machine/cpu.h
+patching file include/machine/pic.h
+patching file include/machine/plugbox.h
+patching file include/useful/keyboard.h
+patching file include/useful/panic.h
+patching file include/useful/plugbox.h
+patching file include/user/task2.h
+patching file src/device/keyboard.cc
+patching file src/device/panic.cc
+patching file src/machine/pic.cc
+patching file src/machine/plugbox.cc
+patching file src/main.cc
+Hunk #3 FAILED at 65.
+1 out of 3 hunks FAILED -- saving rejects to file src/main.cc.rej
+patching file src/user/task1.cc
+patching file src/user/task2.cc
+ubuntu@ubuntuPC:/data/oostubs/oostubs$ 
+\endverbatim
+ * Die Datei main.cc konnte nicht erfolgreich aktualisiert werden. Die letzte der drei 
+ * Änderungen schlug fehl, vermutlich um Zeile 65. Durch den Fehler gibt es jetzt drei 
+ * verschiedene Dateien: main.cc, main.cc.rej und main.cc.orig. Die erste Datei enthält
+ * alle erfolgreichen Änderungen, die Datei .rej enthält die Fehler und orig enthält 
+ * den Zustand der Datei vor dem Einspielen der patch-Datei.
+ * Die rej-Datei könnte Aufschluss geben:
+ *
+ * \code{.py}
+ --- src/main.cc	2013-04-27 09:04:58.609128500 +0200
++++ src/main.cc	2013-05-01 19:13:16.249563000 +0200
+@@ -65,7 +80,11 @@
+ void kernel(uint32_t magic, const Multiboot_Info* info){
+   
++  #if USE_TASK == 10
+   TaskClass task(magic, info);
++  #else
++    TaskClass task;
++  #endif
+   
+   task.action();
+   
+
+\endcode
+ *  
+ * Offenbar konnte der Codeabschnitt nicht in der Datei gefunden werden. In der neuen 
+ * Datei hätte der gezeigte Quellcodeabschnitt von Zeile 65 bis Zeile 80 gehen und der Teil 
+ * mit dem Plus hätte eingefügt werden sollen.
+ * 
+ * Ein Blick in die aktuelle main.cc-Datei ab Zeile 65 ergibt:
+ * \code{.py}
+void kernel(uint32_t magic, const Multiboot_Info* info){
+  TaskClass task( magic, info);
+  
+  task.action();
+  
+}
+
+\endcode
+ * 
+ * In der Datei gibt es kleine Änderungen bzgl. Leerzeilen und Leertasten. Die vier neuen Zeilen 
+ * können leicht eingefügt werden und dann ist auch der Patch komplett.
+ * 
+ * <h4>Bilder</h4>
+ * \htmlonly
+        <ul style="margin:2px; padding:0px;">
+          <li style="list-style:none; display:inline; margin:2px; padding:2px;">
+            <a href="patch_01.png">
+              <img width=200 src="small_patch_01.png" />
+            </a>
+          </li>
+          <li style="list-style:none; display:inline; margin:2px; padding:2px;">
+            <a href="patch_02.png">
+              <img width=200 src="small_patch_02.png" />
+            </a>
+          </li>
+        </ul>
+ \endhtmlonly
+ * 
  * \~english
  * \page devenv Development Environment
  * There is no english description. Use the german version.
Binary files Aufgabe1_Lsg/doc/pics/patch_01.png and Aufgabe2/doc/pics/patch_01.png differ
Binary files Aufgabe1_Lsg/doc/pics/patch_02.png and Aufgabe2/doc/pics/patch_02.png differ
Binary files Aufgabe1_Lsg/doc/pics/small_patch_01.png and Aufgabe2/doc/pics/small_patch_01.png differ
Binary files Aufgabe1_Lsg/doc/pics/small_patch_02.png and Aufgabe2/doc/pics/small_patch_02.png differ
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/doc/task1.dox Aufgabe2/doc/task1.dox
--- Aufgabe1_Lsg/doc/task1.dox	2013-04-27 09:04:48.389543900 +0200
+++ Aufgabe2/doc/task1.dox	2013-05-01 23:14:33.435610700 +0200
@@ -11,11 +11,11 @@
  * \section task1_sec2 Aufgabe
  * Testausgaben können die Fehlersuche vereinfachen und bieten eine gute Gelegenheit, 
  * sich in eine vorgegebene Entwicklungsumgebung einzuarbeiten. Aus diesem Grund soll 
- * unser Übungsbetriebssystem oo-StuBS als erstes solche Ausgabefunktionen erhalten. 
+ * unser Übungsbetriebssystem OOStuBS als erstes solche Ausgabefunktionen erhalten. 
  * Die zu implementierenden Ausgabefunktionen sollen ähnlich wie die IO-Streams der 
  * C++ Bibliothek verwendet werden können und mit Hilfe der Klassen IO_Port (wird von 
  * uns vorgegeben), CGA_Screen, Stringbuffer, O_Stream und CGA_Stream umgesetzt werden. 
- * Damit die Ausgabefunktionen auch überall in oo-StuBS verwendet werden können, soll ein 
+ * Damit die Ausgabefunktionen auch überall in OOStuBS verwendet werden können, soll ein 
  * globales CGA_Stream Objekt kout erzeugt werden. Um darüber hinaus auch interaktive 
  * Anwendungsprogramme zu erlauben, sollt ihr zusätzlich noch die Klasse Keyboard_Controller 
  * vervollständigen, die neben Key in der Vorgabe enthalten ist.
@@ -24,16 +24,10 @@
     size="4.2,4.2";
     node [shape=box, style="solid,filled", fillcolor=white];
     
-    {rank=same; kernelF;task1C;}
-    subgraph cluster_submain {
-      style=filled;
-      color=none;
-      label = "";
-      labeljust=l;
       kernelF [label="kernel(...)", shape=oval, URL="\ref kernel"];
-    }
     
     subgraph cluster_subuser {
+      rank="source";
       style=filled;
       color=lightgray;
       label = "user";
@@ -41,6 +35,14 @@
       task1C [label="Task1", URL="\ref Task1"];
     }
     
+    subgraph cluster_subdevice {
+      style=filled;
+      color=lightgray;
+      label = "device";
+      labeljust=r;
+      cgastrC [label="CGA_Stream", URL="\ref CGA_Stream", color=blue];
+    }
+    
     subgraph cluster_submachine {
       style=filled;
       color=lightgray;
@@ -56,14 +58,6 @@
       keyC -> keyctrlC [arrowhead="ediamond"];
     }
     
-    subgraph cluster_subdevice {
-      style=filled;
-      color=lightgray;
-      label = "device";
-      labeljust=r;
-      cgastrC [label="CGA_Stream", URL="\ref CGA_Stream", color=blue];
-    }
-    
     subgraph cluster_subobject {
       style=filled;
       color=lightgray;
@@ -74,7 +68,7 @@
       ostrC -> strbufC [arrowhead="empty"];
     }
     
-    kernelF -> task1C [arrowhead="open"];
+    kernelF -> task1C [arrowhead="open", constraint=false];
     task1C -> cgastrC [arrowhead="open"];
     task1C -> keyctrlC [arrowhead="open"];
     cgastrC -> cgascrC [arrowhead="empty"];
@@ -123,7 +117,7 @@
  * den Video-RAM zu übertragen. Die Umsetzung des ASCII-Codes in eine Pixelmatrix wird 
  * dann eigenständig von der Grafikkarte vorgenommen.
  *
- * In der Übung zur Vorlesung sollen alle Ausgaben des Betriebssystems oo-StuBS im 
+ * In der Übung zur Vorlesung sollen alle Ausgaben des Betriebssystems OOStuBS im 
  * CGA-Textmodus erfolgen. Dieser Modus wird von fast allen Grafikkarten unterstützt, 
  * ist einfach zu programmieren und für ein Übungsbetriebssystem vollkommen ausreichend.
  * 
@@ -261,7 +255,7 @@
  * dann über das Datenregister. Daten- und Indexregister können direkt mit Hilfe der in und 
  * out Befehle angesprochen werden, da ihnen eigenständige Portadressen zugeordnet sind:
  * <table rules="all" border="1">
- *   <tr><td><strong>Port</strong></td><td><strong>Register</strong></td><td><strong>Zugriffsart</strong></td></tr>
+ *   <tr><th><strong>Port</strong></th><th><strong>Register</strong></th><th><strong>Zugriffsart</strong></th></tr>
  *   <tr><td>3d4</td><td>Indexregister</td><td>nur schreiben</td></tr>
  *   <tr><td>3d5</td><td>Datenregister</td><td>lesen und schreiben</td></tr>
  * </table>
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/doc/task2.dox Aufgabe2/doc/task2.dox
--- Aufgabe1_Lsg/doc/task2.dox	2013-04-27 09:04:48.448547300 +0200
+++ Aufgabe2/doc/task2.dox	2013-05-02 01:05:43.822646100 +0200
@@ -3,7 +3,148 @@
  * \page task2 Aufgabe 2 - Interrupts
  * \tableofcontents
  * 
- * Die Informationen dieser Aufgabe erscheinen mit dem entsprechenden Patch.
+ * \section task2_sec1 Ziele
+ *   \li Behandlung asynchroner Ereignisse
+ *   \li Problematik und Schutz kritischer Abschnitte
+ * 
+ * \section task1_sec2 Aufgabe
+ * Es soll eine einfache Interruptbehandlung für die Unterbrechungen durch Tastaturereignisse 
+ * umgesetzt werden. Hierzu müssen die Klassen \ref CPU (bereits implementiert), \ref PIC, 
+ * \ref Plugbox, \ref Gate, \ref Panic, \ref Keyboard sowie die Funktion \ref guardian() 
+ * implementiert werden. Um die entsprechenden Geräte überall in OOStuBS nutzen zu können, 
+ * sollen von diesen Klassen die globale Objekte \c cpu, \c plugbox, \c pic und \c keyboard 
+ * angelegt werden. 
+ * Dies ist bereits geschehen.
+ * 
+\dot
+  digraph task1 {
+    size="5.9,5.5";
+    node [shape=box, style="solid,filled", fillcolor=white];
+    
+    
+    kernelF [label="kernel(...)", shape=oval, URL="\ref kernel"];
+    
+    subgraph cluster_subuser {
+      rank="source";
+      style=filled;
+      color=lightgray;
+      label = "user";
+      labeljust=l;
+      task2C [label="Task2", URL="\ref Task2"];
+    }
+    
+    subgraph cluster_submachine {
+      style=filled;
+      color=lightgray;
+      label = "machine";
+      labeljust=r;
+      keyctrlC [label="Keyboard_Controller", URL="\ref Keyboard_Controller"];
+      plugboxC [label="Plugbox", URL="\ref Plugbox", color=blue];
+      picC [label="PIC", URL="\ref PIC", color=blue];
+      cpuC [label="CPU", URL="\ref CPU"];
+      cgascrC [label="CGA_Screen", URL="\ref CGA_Screen"];
+      keyC [label="Key", URL="\ref Key"];
+      {rank=max; keyC;}
+      keyC -> keyctrlC [arrowhead="ediamond"];
+    }
+    
+    subgraph cluster_subguard {
+      style=filled;
+      color=lightgray;
+      label = "guard";
+      labeljust=c;
+      gateC [label="Gate", URL="\ref Gate"];
+      guardianF [label="guardian(...)", shape=oval, URL="\ref guardian", color=blue];
+    }
+    
+    subgraph cluster_subdevice {
+      style=filled;
+      color=lightgray;
+      label = "device";
+      labeljust=c;
+      panicC [label="Panic", URL="\ref Panic", color=blue];
+      keyboardC [label="Keyboard", URL="\ref Keyboard", color=blue];
+    }
+    
+    
+    kernelF -> task2C [arrowhead="open"];
+    task2C -> cgascrC [arrowhead="open"];
+    task2C -> cpuC [arrowhead="open"];
+    panicC -> cpuC [arrowhead="open"];
+    panicC -> gateC [arrowhead="empty"];
+    keyboardC -> keyctrlC [arrowhead="empty"];
+    keyboardC -> gateC [arrowhead="empty"];
+    keyboardC -> picC [arrowhead="open", weight=3];
+    keyboardC -> plugboxC [arrowhead="open", weight=4];
+    plugboxC -> gateC [arrowhead="open", weight=2];
+    //plugboxC -> panicC [arrowhead="open"];
+    //plugboxC -> keyboardC [arrowhead="open"];
+    guardianF -> plugboxC [arrowhead="open", weight=5];
+  }
+\enddot
+ * 
+ * \section task2_sec3 Implementierung
+ * 
+ * \subsection task2_sec3_1 Teil A
+ * Im ersten Schritt sollte die Klasse \ref PIC implementiert werden. Mit ihrer Hilfe 
+ * und der Klasse \ref CPU können Unterbrechungen von der Tastatur zugelassen werden 
+ * (während des Boot-Vorgangs werden alle Unterbrechungen bei der CPU deaktiviert). 
+ * Nach der Implementierung des PIC müsste automatisch bei jedem Betätigen einer 
+ * Taste die Funktion guardian() aktiviert werden, da die Interruptdeskriptortabelle im 
+ * Startup-Code entsprechend initialisiert wurde. Mit einer Ausgabe in guardian() kann 
+ * Teil A dann leicht getestet werden (zumindestens einige Male).
+ * 
+ * \note
+ * Da die Zeichen noch nicht vom Tastaturcontroller abgeholt werden, läuft der 
+ * Tastaturpuffer irgendwann voll. Sobald dies geschehen ist, sendet der 
+ * Tastaturcontroller keine Interrupts mehr. Deshalb kann es durchaus passieren, 
+ * dass zunächst nur für ein oder zwei Tastendrücke Interrupts angezeigt werden.
+ * 
+ * \note
+ * Während der Bearbeitung einer Unterbrechung muss sich nicht um unerwünschte 
+ * Interrupts gekümmert werden. Der Prozessor schaltet diese automatisch aus, 
+ * wenn er mit der Behandlung beginnt und lässt sie erst wieder zu, wenn 
+ * die Unterbrechungsbehandlung mit der Assembleranweisung \c iret beendet wird. 
+ * Die vorhandene Implementierung führt dazu, dass dies quasi der letzten 
+ * schließenden Klammer der \ref guardian() entspricht.
+ * 
+ * \attention
+ * Die Interruptverarbeitung kann natürlich nur funktionieren, wenn 
+ * OOStuBS auch läuft. Sobald die \ref kernel()-Funktion verlassen wird, ist das 
+ * Verhalten beim Auftreten eines Interrupts undefiniert. Ein Betriebssystem 
+ * sollte nicht plötzlich enden! ;-)
+ * 
+ * \subsection task2_sec3_2 Teil B
+ * Im zweiten Schritt soll eine Infrastruktur geschaffen werden, die die Behandlung von 
+ * Unterbrechungen durch zugeordnete Gerätetreiberobjekte ermöglicht. Zur Verwaltung 
+ * dieser Treiberobjekte dient dabei die Klasse \ref Plugbox, die für jeden möglichen Interrupt 
+ * einen Zeiger auf ein \ref Gate - Objekt bereithält. Die abstrakte Klasse Gate beschreibt dazu 
+ * die Schnittstelle aller Treiber, die Interrupts behandeln.
+ * 
+ * \note
+ * Alle Zeiger der \ref Plugbox sollen initial so gesetzt werden, dass sie auf ein globales 
+ * \ref Panic - Objekt verweisen.
+ * 
+ * \subsection task2_sec3_3 Teil C
+ * Im nächsten Schritt sollen Unterbrechungen, die von der Tastatur ausgelöst werden, 
+ * abgefangen und interpretiert werden. Als Ergebnis soll nach jedem Tastendruck das 
+ * entsprechende Zeichen an einer festen Position auf dem Bildschirm dargestellt werden. 
+ * Zusätzlich soll die Tastenkombination <b>Ctrl-Alt-Delete</b> einen <b>Reboot</b> auslösen. 
+ * Hierzu soll die Klasse \ref Keyboard implementiert werden, die den eigentlichen 
+ * Tastaturtreiber darstellt.
+ * 
+ * \subsection task2_sec3_4 Teil D
+ * Anschließend solltet ihr am oberen Bildschirmrand eine Laufzeile mit Sternen 
+ * sehen und am unteren Bildschirmrand Tastatureingaben machen können. Allerdings 
+ * werden nach kurzer Zeit merkwürdige Artefakte auftreten. Wo könnten diese her kommen? 
+ * Was kann gegen sie unternommen werden?
+ * 
+ * \note
+ * Die Artefakte sind Teil der Aufgabe und kein Fehler.
+ * 
+ * \section task2_sec4 Hilfestellung
+ *   \li \subpage task2_pic
+ *   \li <a href="http://www.bjoern-koester.de/iogrundlagen/">Input/Output-Grundlagen</a>
  * 
  * \~english
  * \page task2 Task 2 - Interrupts
@@ -11,3 +152,188 @@
  * There is no english describtion. Use the german one.
  */
 
+/**
+ * \~german
+ * \page task2_pic Informationen zum Programmierbaren Interrupt Controller
+ * \tableofcontents
+ * 
+ * \section task2_pic_sec1 Grundlagen
+ * Der %PIC 8259A ist ein Chip - meist nur Teil eines Chips- der wie der Prozessor 
+ * selbst auf dem Motherboard eines jeden PCs zu finden ist. Seine Aufgabe besteht 
+ * in der Koordination der Unterbrechungsanforderungen der verschiedenen Geräte.
+ * 
+ * Dazu besitzt der %PIC acht Eingänge \c IR0 bis \c IR7, an die jeweils der 
+ * Interruptausgang eines Gerätes angeschlossen werden kann. Beispiele für 
+ * diese Geräte sind der Timer, die Tastatur, die seriellen Schnittstellen 
+ * (Maus) und der Festplattencontroller. Die Nummer des IR Pins gibt gleichzeitig 
+ * die Priorität der Unterbrechung an. Das Gerät, das an IR0 angeschlossen ist, 
+ * wird mit höchster Priorität behandelt, das an \c IR7 mit der niedrigsten.
+ * 
+ * Der %PIC hat mehrere Ausgänge, durch die er mit der %CPU verbunden ist. 
+ * Unter anderem ist der Pin INT des PICs direkt an den Pin \c INTR der %CPU 
+ * angeschlossen, ebenso sind die bei %PIC und %CPU gleichermaßen mit \c INTA 
+ * bezeichneten Pins gekoppelt. Die Pins \c D0 bis \c D7 des PICs sind mit den 
+ * acht niederwertigsten Leiterbahnen des Datenbusses verbunden.
+ * 
+ * Wenn der %PIC feststellt, dass auf mindestens einem seiner Eingänge 
+ * \c IR0 bis \c IR7 eine Interruptanforderung anliegt und dem %PIC nicht 
+ * mitgeteilt wurde, dass er die entsprechende Anforderung ignorieren soll, 
+ * so gibt er die Interruptanforderung über seinen Ausgang \c INTR an die %CPU 
+ * weiter. Diese wird die Anforderung mit Hilfe der \c INTA Leitung quittieren 
+ * und durch ein zweites Signal auf \c INTA nach der Nummer des Interrupts fragen. 
+ * Der %PIC antwortet daraufhin, indem er die Nummer des Interrupts 
+ * (gleich der Nummer der Eingangsleitung + einem Offset) auf den Datenbus legt. 
+ * Die %CPU ist nun in der Lage, die Anfangsadresse der Unterbrechungsbehandlungsroutine 
+ * zu finden und die Unterbrechungsbehandlung zu starten.
+ * 
+ * \subsection task2_pic_sec1_1 Regiester
+ * Damit der %PIC sich merken kann, von welchen Geräten er Interruptanforderungen 
+ * erhalten hat, welche er ignorieren soll und welche gerade von der %CPU behandelt werden, 
+ * besitzt er drei interne Register, die jeweils acht Bit breit sind.
+ * 
+ * \subsubsection task2_pic_sec1_1_1 Interrupt-Request Register (IRR)
+ * Hier speichert der %PIC, auf welchen der IR Leitungen eine Interruptanforderung 
+ * signalisiert wurden. Dadurch braucht das betreffende Gerät nur eine kurze 
+ * Änderung des Pegels auf der Leitung auszulösen.
+ * 
+ * \subsubsection task2_pic_sec1_1_2 Interrupt-Service Register (ISR)
+ * Liegen die Interruptanforderungen mehrerer Geräte gleichzeitig an, 
+ * so wird der %PIC zunächst nur die wichtigste weiterleiten. Dazu wird 
+ * die Unterbrechungsanforderung der %CPU über die Leitung \c INT angezeigt. 
+ * Sobald diese daraufhin mit zwei INTA Signalen reagiert hat, wird nicht nur 
+ * die Nummer des Interrupts auf den Datenleitungen \c D0 bis \c D7 ausgegeben, 
+ * sondern auch das entsprechende Bit im \c ISR gesetzt. Gleichzeitig wird das 
+ * Bit im \c IRR gelöscht. Da das Bit im \c ISR gesetzt bleibt, bis es von der 
+ * Unterbrechungsbehandlungsroutine mit Hilfe eines speziellen Befehls explizit 
+ * gelöscht wird, kann der %PIC beim Eintreffen einer weiteren Unterbrechung 
+ * leicht erkennen, ob diese noch wichtiger als die gerade bearbeitete ist. 
+ * In diesem Fall wird er dies der %CPU durch ein erneutes Signal auf der 
+ * \c INT Leitung mitteilen.
+ * 
+ * \subsubsection task2_pic_sec1_1_3 Interrupt-Mask Register (IMR)
+ * Mit Hilfe dieses Registers ist es möglich, Interrupts selektiv zu 
+ * unterdrücken. Ein gesetztes Bit im IMR sorgt dafür, dass der %PIC Interrupts 
+ * des entsprechenden Gerätes ignoriert.
+ * 
+ * \subsection task2_pic_sec1_2 Master-Slave-System
+ * Um mehr als acht Interruptquellen unterscheiden zu können, enthalten 
+ * moderne PCs - das heißt alle ab dem XT von 1983 - zwei PICs, die 
+ * hintereinander geschaltet sind. Der \c INT Ausgang des Slave-PICs hat also 
+ * keine direkte Verbindung zu dem \c INTR Eingang der %CPU, sondern wird an einen 
+ * der IR Einänge (IR2) des Master PICs angeschlossen. Außerdem stehen Master und 
+ * Slave über drei weitere Leitungen in Verbindungen, über die der Master dem Slave 
+ * mitteilen kann, wann dieser die Nummer des von ihm signalisierten Interrupts 
+ * auf den Datenbus legen soll.
+ * 
+ * OOStuBS implementiert das Master-Slave in der Klasse \ref PIC.
+ * 
+ * Mittlerweile wird der \c APIC - Advanced Programmable Interrupt Controller - verwendet. 
+ * Mit diesem ist ein Mehrkern- und Mehrprozessorbetrieb möglich. OOStuBS verwendet diesen 
+ * allerdings nicht. Das Grundprinzip kann nach wie vor mit dem einfacher zu bedienenden 
+ * %PIC verdeutlicht werden.
+ * 
+ * \section task2_pic_sec2 Software
+ * 
+ * \subsection task2_pic_sec2_1 Ignorieren eines Interrupts
+ * %CPU-seitig kann dafür gesorgt werden, dass das laufende Programm nicht durch 
+ * Interrupts unterbrochen wird. Dazu wird mit der Assembleranweisung \c cli das 
+ * Interrupt-Bit im \c EFLAGS -Register gelöscht. Der Prozessor wird auf Signale 
+ * seiner \c INTR Leitung nun nicht mehr reagieren. Da der %PIC einen Interrupt 
+ * frühestens dann weitergibt, wenn die %CPU auf den vorhergehenden Interrupt 
+ * reagiert hat, wird der %PIC keine Interrupts weiterleiten, solange die %CPU 
+ * Interrupts ignoriert. \n
+ * Dieser Vorgang kann mit dem Befehl \c sti wieder rückgängig gemacht werden.
+ * 
+ * Interrupts können auch selektiv unterdrückt werden. 
+ * Dazu muss der %PIC programmiert werden. Das geht wie üblich mit 
+ * \c in und \c out Befehlen.
+ * 
+ * \subsection task2_pic_sec2_2 Software zur Interruptbehandlung
+ * Wenn ein Interrupt ankommt, der sowohl seitens des %PICs als auch seitens 
+ * der %CPU zugelassen wurde, verzweigt der Prozessor automatisch zur 
+ * Interruptbehandlungsroutine.
+ * 
+ * Deren Adresse wird einer Interruptdeskriptortabelle (\c IDT) entnommen, wobei die von 
+ * dem %PIC auf den Datenbus gelegte Nummer des Interrupts als Index dient. 
+ * Beim 8086 Prozessor war die Lage der Interruptdeskriptortabelle noch fest von 
+ * der Hardware vorgegeben, ab dem 80386 wird ihr Anfang und ihre Größe durch 
+ * das IDT-Register beschrieben.
+ * 
+ * Die Interruptdeskriptortabelle kann maximal 256 Interruptgate-Deskriptoren enthalten, 
+ * von denen es drei verschiedene Typen gibt
+ * \li <b>Task-Gate</b>\n
+ *   Der Taskgate-Deskriptor zeigt auf einen Task, einen hardwaremäßig unterstützten Prozeß. 
+ *   Wenn der entsprechende Interrupt eintritt, führt der Prozessor automatisch einen 
+ *   Taskwechsel zu dem angegebenen Interrupt-Task durch.
+ * \li <b>Interrupt-Gate</b>\n
+ *   Der Interruptgate-Deskriptor zeigt auf eine Prozedur, die als 
+ *   Interruptbehandlungsroutine ohne vorherigen Taskwechsel aufgerufen wird.
+ * \li <b>Trap-Gate</b>\n
+ *   Der Trapgate-Deskriptor zeigt auf eine Prozedur, die als 
+ *   Trapbehandlungsroutine ohne vorherigen Taskwechsel aufgerufen wird.
+ * 
+ * Bevor der Prozessor infolge eines Interrupts oder Traps die 
+ * angegebene Behandlungsroutine aufruft, legt er den aktuellen 
+ * Inhalt des \c EFLAGS -Registers auf den Stack ab. Dies ermöglicht es 
+ * ihm, nun das Interrupt-Enable-Flag im \c EFLAGS -Register zu löschen und 
+ * auf diese Weise die geschachtelte Behandlung weiterer Interrupts zu 
+ * verhindern. Wie bei einem normalen Funktionsaufruf wird dann noch die 
+ * Rücksprungadresse - Inhalt von Code-Segment und Instruction Pointer - 
+ * auf dem Stack gesichert, bevor die Behandlungsroutine begonnen wird. \n
+ * Bei manchen Exceptions legt der Prozessor zusätzlich einen Fehlercode auf dem Stack ab.
+ * 
+ * Wurde die Unterbrechung durch einen Interrupt ausgelöst, besteht eine 
+ * Aufgabe der Interruptbehandlungsroutine darin, dem %PIC mitzuteilen, 
+ * dass der Interrupt behandelt wurde. Anderenfalls wird der %PIC nämlich 
+ * keine weiteren Interrupts desselben Gerätes weiterleiten. Das Senden 
+ * dieses Interrupt-Acknowledge-Signals erfolgt wieder mit einem bzw. bei einer 
+ * Kaskadierung der PICs mit zwei out Befehlen an den Port des PICs.
+ * 
+ * Mit dem \c iret Befehl wird die Unterbrechungsbehandlung abgeschlossen. 
+ * Der Prozessor holt die Rücksprungadresse vom Stack, stellt den Inhalt 
+ * des \c EFLAGS -Registers wieder her und kehrt zu der unterbrochenen 
+ * Methode zurück. Dadurch, dass auch die \c EFLAGS wieder hergestellt werden, 
+ * werden spätestens jetzt die Interrupts %CPU-seitig wieder zugelassen.
+ * 
+ * \subsection task2_pic_sec2_3 Zugriff auf die PICs über Ports
+ * Jedem der beiden PICs in einem PC sind zwei Ports im I/O-Adressraum zugeordnet, 
+ * die wie folgt belegt sind:
+ * <table rules="all" border="1">
+ *   <tr><th><strong>Port</strong>(IRQ0-7/IRQ8-15)</th><th><strong>Lesedaten</strong></th><th><strong>Schreibdaten</strong></th></tr>
+ *   <tr><td>0x20 / 0xa0</td><td>IRR, ISR, Int.Vektor</td><td>ICW1, OCW2, OCW3</td></tr>
+ *   <tr><td>0x21 / 0xa1</td><td>IMR</td><td>ICW2, ICW3, ICW4, OCW1</td></tr>
+ * </table>
+ * 
+ * Die Bezeichnungen \c ICW und \c OCW stehend dabei für 
+ * Initialization Control Word und Operation Control Word. 
+ * Für die Lösung der Aufgabe sind nur die Operationsbefehlsworte 
+ * \c OCW1 und \c OCW2 relevant:
+ * \li \c OCW1 ist schlicht ein Platzhalter für die Maske der gesperrten Interrupts. 
+ *     Diese Maske wird direkt in das Interrupt Mask Register (\c IMR, \c 0x21/0xa1) 
+ *     übertragen; ein gesetztes Bit X sorgt dafür, dass der entsprechende Interrupt X 
+ *     gesperrt wird.
+ * \li \c OCW2 wird verwendet um dem %PIC einen \c EOI -Befehl zu senden, 
+ *     damit dieser erfährt, dass der Interrupt bearbeitet wird und das 
+ *     gesetzte Bit im \c ISR löscht. Bei OOStuBS verwenden wir den 
+ *     "unspezifischen \c EOI -Befehl": \c OCW2 == \c 0x20 wird nach der 
+ *     Bearbeitung eines Interrupts in die Kontrollregister \c 0x20/0xa0 geschrieben.
+ * 
+ * Die Initialisierungsbefehlsworte \c ICW1 bis \c ICW4 dienen der 
+ * Initialisierung des Chips. Dies erfolgt bei OOStuBS innerhalb des 
+ * Konstruktors des %PIC, so dass ihr euch darum ausnahmsweise mal 
+ * nicht selber kümmern müsst.
+ * 
+ * \section task2_pic_sec3 Literatur
+ * 
+ * \li <a href="http://www.lowlevel.eu/wiki/Programmable_Interrupt_Controller">PIC auf lowlevel.eu</a>
+ * \li <a href="http://wiki.osdev.org/8259_PIC">8259 PIC auf osdev.org</a>
+ * \li Hans-Peter Messmer, "PC-Hardwarebuch", Addison-Wesley, 1995
+ * \li Intel, "8259A - Programmable Interrupt Controller"
+ * \li Andreas Roth, "Das Computer-Peripherie Kochbuch", IWT Verlag, 1990
+ * \li Klaus-Dieter Thies, "80386 - Die innovativen 80286/80386 Architekturen", tewi Verlag, 1988
+ * 
+ * \~english
+ * \page task2_pic Informationen zum Programmierbaren Interrupt Controller
+ * 
+ * There is no english describtion. Use the german one.
+ */
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/device/keyboard.h Aufgabe2/include/device/keyboard.h
--- Aufgabe1_Lsg/include/device/keyboard.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/device/keyboard.h	2013-05-02 02:10:50.644749500 +0200
@@ -0,0 +1,77 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                       K E Y B O A R D                                         * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __keyboard_include__
+#define __keyboard_include__
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/keyctrl.h"
+#include "guard/gate.h"
+#include "machine/key.h"
+ 
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    CLASSES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** 
+ * \~german
+ * \brief Treiber für die Tastatur, incl. Interruptunterstützung.
+ * 
+ * Diese Klasse ist von Gate abgeleitet und implementiert die Interruptroutine der Tastatur.
+ * 
+ * \~english
+ * \brief %Keyboard driver with interrupt support
+ *
+ * This class is a subclass of Gate and implements the interrupt routine used 
+ * for the keyboard.
+ */
+class Keyboard : public Keyboard_Controller, public Gate  {
+  public:
+     
+     /** 
+      * \~german
+      * \brief Der Konstruktor ruft die vorherigen Konstruktoren auf.
+      * 
+      * \~english
+      * \brief constructor only calls constructor of base classes up to now
+      */
+     Keyboard();
+     
+    /** 
+     * \~german
+     * \brief aktiviert den Interruptmechanismus für die Tastatur
+     * 
+     * Die Methode aktiviert die Keyboard Interrupts. Nach dem Aufruf werden die Interrupts, 
+     * welche durch die Tastatur generiert werden, weitergereicht. Die Behandlung ist dann 
+     * mit trigger möglich.
+     * 
+     * \~english
+     * \brief enable the interrupt mechanism of the keyboard
+     * 
+     * Method plugin() enables all keyboard interrupts. After calling plugin()
+     * interrupts activated by the keyboard are recognised.
+     */
+    void plugin ();
+    
+    /** 
+     * \~german
+     * \brief einen auftretenden Tastaturinterrupt behandeln
+     * 
+     * Tritt ein Interrupt für die Tastatur auf, so soll diese Funktion aufgerufen werden.
+     * 
+     * In Aufgabe 2 soll die Funktion das eingegeben Zeichen an einer festen Position, z.B.
+     * x=4, y=10, auf dem Bildschirm ausgeben.
+     * 
+     * \~english
+     * \brief handle keyboard interrupt
+     */
+    virtual void trigger ();
+};
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/device/panic.h Aufgabe2/include/device/panic.h
--- Aufgabe1_Lsg/include/device/panic.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/device/panic.h	2013-05-02 01:00:38.697400100 +0200
@@ -0,0 +1,61 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                          P A N I C                                            * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __panic_include__
+#define __panic_include__
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "guard/gate.h"
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    CLASSES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** 
+ * \~german
+ * \brief Standardinterruptbehandlungsroutine
+ * 
+ * Diese Klasse, als Unterklasse von Gate, implementiert eine Standardroutine zur 
+ * Behandlung von Interrupts. Sie soll immer dann genommen werden, wenn ein 
+ * unbekannter oder nicht-registrierter Interrupt aufgetreten ist.
+ * 
+ * \~english
+ * \brief Default interrupt handler
+ *
+ * This class is a subclass of Gate and implements a standard interrupt routine
+ * used as default for unknown/registered interrupts.
+ */
+class Panic  : public Gate {
+  public:
+    /** 
+     * \~german
+     * \brief Der Konstruktor ruft die vorherigen Konstruktoren auf.
+     * 
+     * \~english
+     * \brief constructor only calls constructor of base classes up to now
+     */
+    Panic();
+    
+    /**  
+     * \~german
+     * \brief handelt unbekannte oder nicht-registrierte Interrupts
+     * 
+     * Zum Debuggen sollte die Nummer des Interrupts ausgegeben werden und die %CPU 
+     * für immer angehalten werden.
+     * 
+     * \~english
+     * \brief handle unknown/unregistered interrupt 
+     *
+     * For debug purposes the cpu will be halted if an unknown interrupt occurs.
+     **/
+    virtual void trigger();
+    
+};
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/guard/gate.h Aufgabe2/include/guard/gate.h
--- Aufgabe1_Lsg/include/guard/gate.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/guard/gate.h	2013-05-02 01:49:59.596386500 +0200
@@ -0,0 +1,95 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                          G A T E                                              * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __gate_include__
+#define __gate_include__
+
+/** 
+ * \~german
+ * \brief Basisklasse für die Interruptbehandlung
+ * 
+ * Mit Hilfe dieser Überklasse kann eine Menge von Klassen die Behandlung von Interrupts 
+ * durchführen. Jede Unterklasse muss die Funktion \ref trigger() mit den jeweiligen, gewünschten 
+ * Verhalten implementieren.
+ * 
+ * \~english
+ * \brief Interrupt handling base class
+ *
+ * Superclass of a set of classes that are able to handle interrupts. Every
+ * subclass of Gate has to implement method trigger() with appropriated
+ * behavior.
+ **/
+class Gate {
+  protected:
+    /**
+     * \~german
+     * \brief Nummer des Interrupts, der die Behandlung durch dieses Gates ausgelöst hat
+     * 
+     * \~english
+     * \brief number of occured interrupt
+     */
+    unsigned short gateInterruptNumber;
+    
+  public:
+    
+    /**
+     * \~german
+     * \brief Konstruktor setzt \ref gateInterruptNumber auf einen ungueltigen Wert
+     * 
+     * \~english
+     * \brief set \ref gateInterruptNumber to an illigal value
+     */
+    Gate(): gateInterruptNumber(256){}
+    
+    /** 
+     * \~german
+     * \brief abstrakte Funktion zur Interruptbehandlung
+     * 
+     * Tritt ein bestimmter Interrupt auf, so wird diese Funktion der entsprechenden 
+     * Unterklasse aufgerufen. Die Ausführung ist asynchron zu den anderen Anweisungen 
+     * des Betriebssystem.
+     * Da es verschiedene Interrupts gibt, die auch unterschiedliches Verhalten erfordern, 
+     * müssen mehrere Unterklassen angelegt werden, je eine pro gewünschten Interrupt. Alle 
+     * anderen Interrupts können auf eine einzige, weitere Unterklasse gelegt werden.
+     * 
+     * \~english
+     * \brief interrupt handling method
+     *
+     * This method is called after an interrupt occured. It is executed 
+     * asynchronous to other activities of the operation system. To enable 
+     * different behavior according to the occured interrupt this method has to 
+     * be implemented in a subclasses of Gate.
+     **/
+    virtual void trigger() = 0;
+    
+    /**
+     * \~german
+     * \brief setzen der Interruptnummer
+     * 
+     * Ein Gateobjekt kann für mehrere Interrupts zuständig sein. Hier sei besonders das
+     * gloabe \ref Panic -Objekt erwähnt. Um die Interrupts unterscheiden zu können kann 
+     * die Nummer vor der Behandlung gesetzt werden.
+     * 
+     * \param slot
+     *   Nummer des aufgetretenen Interrups
+     * 
+     * \~english
+     * \brief set interrupt number
+     * 
+     * It is possible to use one Gate object for multiple objects. To identify the original 
+     * interrupt the number could be set here.
+     * 
+     * \param slot
+     *   number of occured interrupt
+     */
+    void setInterruptNumber(unsigned short slot){
+      gateInterruptNumber = slot;
+    }
+};
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/machine/cpu.h Aufgabe2/include/machine/cpu.h
--- Aufgabe1_Lsg/include/machine/cpu.h	2013-04-27 09:04:39.862056200 +0200
+++ Aufgabe2/include/machine/cpu.h	2013-05-01 15:23:45.800938400 +0200
@@ -9,29 +9,60 @@
 #ifndef __CPU_include__
 #define __CPU_include__
 
-/** \brief Hardware accessor for %CPU specific instructions
+/** 
+ * \~german
+ * \brief Zugriff auf einige spezielle %CPU-Anweisungen
+ * 
+ * Die Klasse implementiert eine abstraktion des Prozessors. Sie bietet Funktionen zum aktivieren 
+ * und deaktivieren von Interrupts im globalen Sinne. Ferner ist es möglich die %CPU anzuhalten.
+ * Ist die %CPU angehalten, so wird sie durch das Auftreten eines Interrupts wieder aktiviert.
+ * 
+ * Um die %CPU für immer anzuhalten ist es notwendig erst die Interrupts zu deaktivieren und danach 
+ * die %CPU anzuhalten.
+ * 
+ * \~english
+ * \brief Hardware accessor for %CPU specific instructions
  *
  * Class CPU implements an abstraction of the processor. It provides methods to
  * enable/disable interrupts globally and to halt the processor.
  */
 class CPU {
   private:
+    /**
+     * \~german 
+     * \brief Diese Variable speichert den letzten Zustand
+     * 
+     * Um den letzten Zustand der Interrupts wieder herzustellen, muss dieser Wert gespeichert 
+     * werden. Bei 0x0200 waren die bisherigen Interrupts an, bei 0 waren sie aus. 
+     * Alle anderen Zustände sind undefiniert und dürfen nicht angenommen werden.
+     * 
+     * \~english
+     * \brief This variable stores the last known state of the interrupt flag.
+     * 
+     * Only 0x0200 for active interrupts and 0 for deaktivated interrupts are allowed.
+     */
     int iIFlag;
     
   public:
     
     /**
      * \~german
-     * \brief ...
+     * \brief Konstruktor setzt \ref iIFlag auf 0
      * 
      * \~english
-     * \brief ...
+     * \brief initialize \ref iIFlag with zero
      **/
     CPU():iIFlag(0){
       
     }
     
-    /** \brief globally enable interrupts **/
+    /** 
+     * \~german
+     * \brief Interrupts werden global aktiviert
+     * 
+     * \~english
+     * \brief globally enable interrupts 
+     */
     inline void enable_int () {
       asm(
         "movl $0x0200, %0 \n\t"
@@ -40,7 +71,13 @@
       );
     }
     
-    /** \brief globally dissable interrupts **/
+    /** 
+     * \~german
+     * \brief Interupts werden global deaktiviert
+     * 
+     * \~english
+     * \brief globally dissable interrupts
+     */
     inline void disable_int () {
       asm(
         "pushf\n\t"
@@ -51,7 +88,17 @@
       );
     }
     
-    /** \brief restore old state of interrupt **/
+    /** 
+     * \~german
+     * \brief stellt den letzten bekannten Zustand des Interrupt-Flags der %CPU wieder her
+     * 
+     * Waren die Interrupts vor der letzten Deaktivierung aktiv, so werden sie wieder aktiviert. 
+     * Waren sie aber bereits ausgeschaltet, so sind sie dies dann weiterhin. Umgekehrt gilt das 
+     * gleiche
+     * 
+     * \~english
+     * \brief restore old, known state of interrupt
+     */
     inline void retore_interrupt_state () {
       asm(
         "cli \n\t"
@@ -64,7 +111,20 @@
       );
     }
     
-    /** \brief halt the cpu
+    /** 
+     * \~german
+     * \brief hält die %CPU an
+     * 
+     * Wenn die %CPU angehalten wird, so wird der Programmzähler (EIP) nicht weiter erhöht und 
+     * die %CPU berechnet keine Anweisung mehr, bis ein Interrupt auftritt. Sobald dies geschieht, 
+     * so behandelt die %CPU diese Unterbrechung und führt dann mit der Ausführung des nächsten 
+     * normalen Befehls fort, so als wäre halt nie aufgerufen worden.
+     * 
+     * Für eine dauerhaftes Anhalten müssen vor dem Aufruf dieser Funktionen die Interrupts 
+     * deaktiviert werden. Dann muss der Computer per Hand ausgeschalten werden.
+     * 
+     * \~english
+     * \brief halt the %cpu
      *
      * When the cpu is halted the program counter will not increase until an
      * interrupt occurs.  If an interrupt occurs the cpu will handle the
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/machine/pic.h Aufgabe2/include/machine/pic.h
--- Aufgabe1_Lsg/include/machine/pic.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/machine/pic.h	2013-05-02 02:26:15.493190300 +0200
@@ -0,0 +1,187 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                            P I C                                              * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __pic_include__
+#define __pic_include__
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/io_port.h"
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    CLASSES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** 
+ * \~german
+ * \brief Treiber für den %PIC (Programmable Interrupt Controller)
+ * 
+ * Der %PIC (programmierbarer Interruptkontroller) ermöglicht es dem System bestimmte Interrupts 
+ * bzw. unterbrechungen zu erlauben oder zu verbieten. Wurden die Interrupts global aktiviert,
+ * so legt der PIC fest, welche Interrupts weitergreicht werden um vom System behandelt zu werden. 
+ * Es ist wichtig,d ass Interrupts nur behandelt werden, falls der entsprechende Interrupt erlaubt 
+ * wurde und die Behandlung im allgemeinen aktiviert ist - siehe dazu die Klasse \ref CPU.
+ * 
+ * Der %PIC basiert auf Intels 8259 Chip und besteht aus einem Master-Slave %PIC-System.
+ * Heutzutage werden sie meist nur "emuliert". Verwendet wird mittlerweile APIC, welcher für 
+ * ein Mehrkernbetrieb notwendig ist.
+ * 
+ * \~english
+ * \brief Driver for Programmable Interrupt Controller
+ *
+ * The %PIC or Programmable Interrupt Controller enables the system to 
+ * allow/forbid interrupts. By allowing an interrupt the PIC defines which
+ * interrupts are handled by the system. It is important that interrupts will
+ * only be handled if the interrupt has been allowed and if the handling of 
+ * interrupts is enabled (see class \ref CPU). 
+ */
+class PIC{
+  public:
+    /** 
+     * \~german
+     * \brief externe Interruptquellen
+     * 
+     * Die folgende Liste gibt die oft genutze Liste der Interrupts an. Sie ist nicht für alle
+     * Computer gleich, da sie sich danach richtet, welche Hardware an den entsprechenden 
+     * Interrupteingang vom PIC angeschlossen ist.
+     * 
+     * Die ersten acht Einträge stammen vom ersten PIC (Master), 
+     * die letzten acht vom zweiten PIC (Slave).
+     * 
+     * \~english
+     * \brief External interrupt sources
+     */
+    enum Interrupts{
+      timer         = 0,  ///< \~german Intervallzähler (PIT) \~english timer (PIT)
+      keyboard      = 1,  ///< \~german Tastaturkontroller \~english keyboard controller
+      pic2          = 2,  ///< \~german Anschluss von Slave-PIC \~english second PIC
+      serial2       = 3,  ///< \~german RS-232 Port 2 und 4 \~english RS-232 port 2 and 4
+      serial1       = 4,  ///< \~german RS-232 Port 1 und 3 \~english RS-232 port 1 and 3
+      soundcard     = 5,  ///< \~german Soundkarte oder LPT 2 \~english sound card or LPT 2
+      floppy        = 6,  ///< \~german Diskettenkontroller \~english floppy disc controller
+      parallelport  = 7,  ///< \~german LPT 1 und unechter Interrupt \~english LPT 1
+      rtc           = 8,  ///< \~german Echtzeituhr vom CMOS (RTC) \~english real time clock
+      misc          = 9,  ///< \~german verschiedene \~english miscellaneous
+      ata4          = 10, ///< \~german vierter ATA(PI)/IDE \~english fourth ATA(PI)/IDE
+      ata3          = 11, ///< \~german dritter ATA(PI)/IDE \~english third ATA(PI)/IDE
+      secondps2     = 12, ///< \~german zweiter Tastaturkontrolleranschluss \~english second keyboard controller port
+      fpu           = 13, ///< \~german Gleitkommazahleneinheit \~english floating point unit
+      ata1          = 14, ///< \~german erster ATA(PI)/IDE \~english first ATA(PI)/IDE
+      ata2          = 15  ///< \~german zweiter ATA(PI)/IDE und unechter Interrupt\~english second ATA(PI)/IDE
+    };
+    
+    /** 
+     * \~german
+     * \brief Standardkonstruktor
+     * 
+     * Er initialisiert den PIC und maskiert alle einkommenden Interrupt, damit wird keiner  an
+     * die %CPU durchgereicht.
+     * 
+     * \~english
+     * \brief Default Constructor
+     *
+     * Setting up the PIC and masking all incoming interrupt channels
+     */
+    PIC();
+  
+    /** 
+     * \~german
+     * \brief erlaubt einen speziellen Interrupt von der Hardware
+     * 
+     * Die Funktion ermöglich dem System Interrupts von speziellen Geräten mit Hilfe des %PICs
+     * zu behandeln. Damit überhaupt ein Interrupt behandelt werden kann muss vorher 
+     * \ref CPU::enable_int() aufgerufen werden um die Interrupts global zu erlauben.
+     * 
+     * \~english
+     * \brief allow a specific hardware interrupt
+     *
+     * Enables the system to handle interrupts of the specified 
+     * device using the %PIC. To enable the handling of any interrupt 
+     * \ref CPU::enable_int() has to be called first.
+     *
+     * \param interrupt 
+     *   number of interrupt that will be allowed
+     */
+    void allow(Interrupts interrupt);
+    
+    /** 
+     * \~german
+     * \brief verbietet einen speziellen Interrupt der Hardware
+     * 
+     * Diese Funktion deaktiviert einen bestimmten Interrupt mit Hilfe des %PICs.
+     * 
+     * 
+     * \~english
+     * \brief forbid a specific hardware interrupt
+     *
+     * Disables an interrupt useing the %PIC.
+     *
+     * \param interrupt 
+     *   number of interrupt that will be forbiden
+     */
+    void forbid(Interrupts interrupt); 
+    
+    /**
+     * \~german
+     * \brief sendet ein "Acknowledgement" eines ausstehenden Interrupts
+     * 
+     * Die Funktion bestätigt die Behandlung eines aufgetretenen Interrupts. Dies sagt dem 
+     * PIC, dass der letzte gemeldete Interrupt abgearbeitet wurde
+     * 
+     * \~english
+     * \brief acknowledge the handling of a pending interrupt
+     *
+     * Acknowledge an occured interrupt. This tells the PIC that his last
+     * interrupt has been handled. This Method has to be called before the cpu is
+     * allowed to handle any new interrupts. If an interrupt is not acknowledged
+     * the same interrupt is called again and again.
+     * 
+     * If an interrupt accures at the slave %PIC than also the first one has to be acknowledged.
+     * 
+     * \param secondPIC
+     *   Should an acknowledgement send to the second and first PIC or yust the first one?
+     */
+    void ack(bool secondPIC);
+    
+    /** 
+     * \~german
+     * \brief den ISR eines der beiden PICs ermitteln
+     * 
+     * Diese Information ist besonders zur Behandlung eines "Spurious Interrupt" interessant. 
+     * Dieser tritt auf, wenn ein Interrupt gemeldet wird. Aber wenn die CPU bereits zur 
+     * Behandlung ist, hat die eigentliche Hardware ihren IRQ zurück genommen. Der PIC muss nun 
+     * die Nummer eines Interrupts melden. Jedoch liegt keiner mehr vor. Deshalb meldet der PIC
+     * dann seine letzte Nummer. Der Slave meldet also 15, der Master die 7.
+     * 
+     * \attention
+     * Sollte der zweite (Slave) PIC den "Spurious Interrupt", so ist dies für den ersten 
+     * ein echter Interrupt. Der erste PIC muss deshalb ein \c ACK erhalten.
+     * 
+     * \note
+     * Eine Behandlung dieser "Spurious Interrupt" in der Funktion \ref guardian ist nur 
+     * optional. Diese Funktion muss aber in jedem Fall inplementiert werden.
+     * 
+     * \param secondPIC
+     *   Soll der ISR des zweiten PICs zurückgegeben werden?
+     * 
+     * \return
+     *   Der ISR des angefragten PICs.
+     * 
+     * \~english
+     * \brief returns the ISR of one of the two PICs
+     * 
+     * \param secondPIC
+     *   Should the ISR of the second PIC be returned?
+     * 
+     * \return
+     *   The ISR of the desired PIC.
+     */
+    unsigned char getISR(bool secondPIC = false);
+};
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/machine/plugbox.h Aufgabe2/include/machine/plugbox.h
--- Aufgabe1_Lsg/include/machine/plugbox.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/machine/plugbox.h	2013-05-02 01:24:32.887019100 +0200
@@ -0,0 +1,107 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                         P L U G B O X                                         * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __plugbox_include__
+#define __plugbox_include__
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "guard/gate.h"
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    CLASSES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** 
+ * \~german
+ * \brief Administrationseinheit für die Interruptweitergabe
+ * 
+ * Diese Klasse abstrahiert die IDT (Interruptdeskriptortabelle). Sie ermöglicht dem
+ * System für jeden Hardware- und jeden Softwareinterrupt eine entsprechende 
+ * Behandlungsroutine zu vergeben und bereit zu stellen.
+ * 
+ * \~english
+ * \brief Interrupt forwarding administration unit
+ *
+ * This Class is an abstraction of the IDT (interrupt descriptor table). It
+ * enables the system to define an appropriate handling routine for every hard
+ * and software interrupt.
+ **/
+class Plugbox {
+  private:
+    /** 
+     * \~german
+     * \brief Array von Zeigern auf Gate-Objekte
+     * 
+     * Der Puffer soll Gate-Zeiger für alle möglichen 256 Interrupts vorhalten.
+     * 
+     * \todo deklarieren
+     * 
+     * \~english
+     * \brief array of pointers to Gate objects
+     * 
+     * The buffer should contain gates for all 256 possible interrupts.
+     *
+     * \todo write declaration
+     **/
+    
+  public:
+    /** 
+     * \~german
+     * \brief Standardkonstruktor
+     * 
+     * Er initialisiert das Array von Gate-Zeiger mit dem globalen \ref Panic -Objekt.
+     * 
+     * \~english
+     * \brief Default constructor
+     *
+     * initialising the map with the global Panic Gate. 
+     **/
+    Plugbox ();
+    
+    /** 
+     * \~german
+     * \brief bindet ein \ref Gate -Objekt an einen speziellen Interrupt
+     * 
+     * \param slot 
+     *   Zahl des Interrupts, welche mit dem Gateobjekt behandelt werden soll
+     * \param gate 
+     *   Referenz auf das Gateobjekt für den Interrupt
+     * 
+     * \~english
+     * \brief assign a Gate object to a specific interrupt
+     *
+     * \param slot 
+     *   number of interrupt the gate object will be assigned to
+     * \param gate 
+     *   reference of the gate object containing the handling routine for the interrupt
+     */
+    void assign(unsigned short slot, Gate& gate) ;
+    
+    /** 
+     * \~german
+     * \brief gibt eine Referenz auf das für den Interrupt richtige \ref Gate -Objekt zurück
+     *
+     * \param slot 
+     *   Nummer des aufgetretenen Interrupts
+     * \return 
+     *   Referenz auf das Gateobjekt, 
+     *   sollte die Zahl ungültig sein, so das globale \ref Panic -Objekt
+     * 
+     * \~english
+     * \brief report the assigned Gate object for a specific interrupt
+     *
+     * \param slot 
+     *   number of occured interrupt 
+     * \return 
+     *   reference of the Gate object or the Panic gate, if none was assigned
+     */
+    Gate& report(unsigned short slot);
+  };
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/useful/keyboard.h Aufgabe2/include/useful/keyboard.h
--- Aufgabe1_Lsg/include/useful/keyboard.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/useful/keyboard.h	2013-05-01 19:17:07.290777800 +0200
@@ -0,0 +1,9 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                        useful/keyboard                                        * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#include "device/keyboard.h"
+extern Keyboard keyboard;
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/useful/panic.h Aufgabe2/include/useful/panic.h
--- Aufgabe1_Lsg/include/useful/panic.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/useful/panic.h	2013-05-01 19:18:08.395272800 +0200
@@ -0,0 +1,9 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                         useful/panic                                          * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#include "device/panic.h"
+extern Panic panic;
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/useful/pic.h Aufgabe2/include/useful/pic.h
--- Aufgabe1_Lsg/include/useful/pic.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/useful/pic.h	2013-05-02 01:41:55.184374000 +0200
@@ -0,0 +1,9 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                 Technische Informatik II                                      *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *                                                                                               *
+ *                                        useful/pic                                             *
+ *                                                                                               *
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/pic.h"
+extern PIC pic;
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/useful/plugbox.h Aufgabe2/include/useful/plugbox.h
--- Aufgabe1_Lsg/include/useful/plugbox.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/useful/plugbox.h	2013-05-01 19:18:42.299212000 +0200
@@ -0,0 +1,9 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *                                                                                               *
+ *                                        useful/plugbox                                         *
+ *                                                                                               *
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/plugbox.h"
+extern Plugbox plugbox;
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/include/user/task2.h Aufgabe2/include/user/task2.h
--- Aufgabe1_Lsg/include/user/task2.h	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/include/user/task2.h	2013-05-01 19:08:43.450959800 +0200
@@ -0,0 +1,51 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                 Technische Informatik II                                      * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                       T A S K 2                                               * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __task2_include__
+#define __task2_include__
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "user/appl.h"
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    CLASSES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/**
+ * \brief Second test application
+ *
+ * This application test the functionality of the implemented interrupt system.
+ * It prints the task identification and then repeatedly draws a line in an
+ * endless loop.  Interrupts from the keyboard are printed onto the screen to a
+ * fixed location. This should disturb the drawing of the line.
+ **/
+
+class Task2 : public Application{
+  public:
+    /** 
+     * \brief Default constructor
+     *
+     * prints task information and enables interrupts
+     **/
+    Task2();
+    
+    /** 
+     * \brief Destructor
+     *
+     * disables interrupts, should never be called due to the endless loop
+     **/
+    virtual ~Task2();
+    
+    /** 
+     * \brief prints the line 
+     */
+    virtual void action();
+};
+
+#endif
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/device/keyboard.cc Aufgabe2/src/device/keyboard.cc
--- Aufgabe1_Lsg/src/device/keyboard.cc	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/src/device/keyboard.cc	2013-05-01 19:06:16.874576200 +0200
@@ -0,0 +1,27 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                       K E Y B O A R D                                         * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "device/keyboard.h"
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    METHODS                      # 
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** \todo \~german implementieren \~english write implementation */
+Keyboard::Keyboard(){
+}
+
+/** \todo \~german implementieren \~english write implementation */
+void Keyboard::plugin(){
+}
+
+/** \todo \~german implementieren \~english write implementation */
+void Keyboard::trigger(){
+}
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/device/panic.cc Aufgabe2/src/device/panic.cc
--- Aufgabe1_Lsg/src/device/panic.cc	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/src/device/panic.cc	2013-05-01 19:05:49.705022100 +0200
@@ -0,0 +1,25 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                          P A N I C                                            * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "device/panic.h"
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    METHODS                      # 
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+
+/** \todo \~german implementieren \~english write implementation*/
+Panic::Panic(){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+void Panic::trigger(){
+}
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/guard/guardian.cc Aufgabe2/src/guard/guardian.cc
--- Aufgabe1_Lsg/src/guard/guardian.cc	2013-04-27 09:04:58.212105800 +0200
+++ Aufgabe2/src/guard/guardian.cc	2013-05-02 01:23:48.587393700 +0200
@@ -6,25 +6,45 @@
  *                                                                                               *
 \* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-/* INCLUDES */
-
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 #include "useful/kout.h"
 #include "useful/cpu.h"
 
-/* GLOBAL OBJECTS */
-
-/* declare methods as c-like  */
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#            declare methods as c-like            #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 extern "C" void guardian (unsigned short slot);
 
 extern "C" void handleException(unsigned short slot, void* eip, unsigned int eflags, unsigned short cs);
 extern "C" void handleExceptionE(unsigned short slot, void* eip, unsigned int eflags, unsigned short cs, unsigned int errorCode);
 extern "C" void handleExceptionReserved(unsigned short slot);
 
-/* METHODS  */
 
-/** \brief Entry point for interrupts
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    METHODS                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+/** 
+ * \~german
+ * \brief Einsprungspunkt für Interrupts
+ * 
+ * Da alle Interrupts hier auftreffen müssen die entsprechenden Interrupts aufgeteilt werden.
+ * Für die ersten 256 Interrupts kann die Plugbox verwendet werden. Alle anderen und damit 
+ * ungültigen Nummern sollten auf das globale \ref Panic -Objekt umgeleitet werden.
+ * 
+ * \param slot
+ *   Nummer des aufgetretenen Interrupts
+ * 
+ * \todo implementieren
+ * 
+ * \~english
+ * \brief Entry point for interrupts
+ * 
+ * \param slot 
+ *   number of occurred interrupt
  *
- * @param slot number of occurred interrupt
+ * \todo write implementation
  */
 void guardian (unsigned short slot) {
   
@@ -51,6 +71,7 @@
   //Fehler melden
   kout.flush();
   kout << endl;
+  kout << FGColor(RED) << BGColor(BLACK) << Blink(false);
   kout << "Exception "    << slot << " occures";
   kout << endl            << "(";
   kout << "cs: "        << dec  << cs;
@@ -84,6 +105,7 @@
   //Fehler melden
   kout.flush();
   kout << endl;
+  kout << FGColor(RED) << BGColor(BLACK) << Blink(false);
   kout << "Exception "    << slot << " occures";
   kout << endl            << "(";
   kout << "cs: "          << dec  << cs;
@@ -110,6 +132,7 @@
   //Fehler melden
   kout.flush();
   kout << endl;
+  kout << FGColor(RED) << BGColor(BLACK) << Blink(false);
   kout << "reserved Exception " << slot << " occures" << endl;
   
   //und anhalten
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/machine/pic.cc Aufgabe2/src/machine/pic.cc
--- Aufgabe1_Lsg/src/machine/pic.cc	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/src/machine/pic.cc	2013-05-02 02:23:50.251747000 +0200
@@ -0,0 +1,56 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                            P I C                                              * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/pic.h"
+#include "machine/io_port.h"
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    METHODS                      # 
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+
+/** \todo \~german verstehen \~english understand */
+PIC::PIC(){
+  IO_Port ctrl_1(0x20), ctrl_2(0xa0), mask_1(0x21), mask_2(0xa1);
+  
+  ctrl_1.outb(0x11);
+  ctrl_2.outb(0x11);
+  
+  mask_1.outb(32);
+  mask_2.outb(40);
+  
+  mask_1.outb(4);
+  mask_2.outb(2);
+  
+  mask_1.outb(3);
+  mask_2.outb(3);
+  
+  mask_1.outb(0xFB);
+  mask_2.outb(0xFF);
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+void PIC::allow(Interrupts interrupt){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+void PIC::forbid(Interrupts interrupt){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+void PIC::ack(bool secondPIC){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+unsigned char PIC::getISR(bool secondPIC){
+  ///todo remove dummy
+  return 0;
+}
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/machine/plugbox.cc Aufgabe2/src/machine/plugbox.cc
--- Aufgabe1_Lsg/src/machine/plugbox.cc	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/src/machine/plugbox.cc	2013-05-01 19:07:15.529931000 +0200
@@ -0,0 +1,32 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                   Technische Informatik II                                    * 
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
+ *                                                                                               * 
+ *                                         P L U G B O X                                         * 
+ *                                                                                               * 
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    INCLUDES                     #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+#include "machine/plugbox.h"
+#include "useful/panic.h"
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    METHODS                      # 
+\* * * * * * * * * * * * * * * * * * * * * * * * */
+
+/** \todo \~german implementieren \~english write implementation*/
+Plugbox::Plugbox(){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+void Plugbox::assign(unsigned short slot, Gate& gate){
+}
+
+/** \todo \~german implementieren \~english write implementation*/
+Gate& Plugbox::report(unsigned short slot){
+  /// \todo Dummy entfernen, remove dummy
+  return panic;
+}
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/main.cc Aufgabe2/src/main.cc
--- Aufgabe1_Lsg/src/main.cc	2013-04-27 09:04:58.609128500 +0200
+++ Aufgabe2/src/main.cc	2013-05-02 00:42:29.846133600 +0200
@@ -6,36 +6,52 @@
  *                                                                                               *
 \* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-/* INCLUDES */
-
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                   INCLUDES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 #include "machine/multiboot.h"
 #include "machine/cpu.h"
-#include "machine/keyctrl.h"
+#include "machine/pic.h"
+#include "machine/plugbox.h"
+
+#include "device/keyboard.h"
 #include "device/cgastr.h"
+#include "device/panic.h"
+
 #include "user/task1.h"
 
-/* MACROS */
 
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                    MACROS                       #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 /// \~german  festlegen, welche Aufgabenanwendung verwendet werden soll
 /// \~english define which task is desired
-#define USE_TASK           10
+#define USE_TASK           20
 
 //load the necessary header and define the class name of the task
 #if USE_TASK == 10
   #include "user/task1.h"
   typedef Task1 TaskClass;
   
-#endif
-
+#elif USE_TASK == 20
+  #include "user/task2.h"
+  typedef Task2 TaskClass;
 
-/* GLOBAL OBJECTS */
+#endif
 
-CGA_Stream kout;
-Keyboard_Controller keyboard;
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                GLOBAL OBJECTS                   #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 CPU cpu;
+PIC pic;
+Panic panic;
+Plugbox plugbox;
+CGA_Stream kout;
+Keyboard keyboard;
 
-/* METHODS  */
-
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                   METHODS                       #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 extern "C" void kernel(uint32_t magic, const Multiboot_Info* info);
 
 /** \brief kernel entry point
@@ -48,7 +64,11 @@
  **/
 void kernel(uint32_t magic, const Multiboot_Info* info){
   
+  #if USE_TASK == 10
   TaskClass task(magic, info);
+  #else
+    TaskClass task;
+  #endif
   
   task.action();
   
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/user/task1.cc Aufgabe2/src/user/task1.cc
--- Aufgabe1_Lsg/src/user/task1.cc	2013-04-27 09:04:58.842141800 +0200
+++ Aufgabe2/src/user/task1.cc	2013-05-01 19:16:00.377950600 +0200
@@ -6,13 +6,16 @@
  *                                                                                               *
 \* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                   INCLUDES                      #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 #include "user/task1.h"
-#include "device/cgastr.h"
-#include "machine/keyctrl.h"
-
-extern CGA_Stream kout;
-extern Keyboard_Controller keyboard;
+#include "useful/kout.h"
+#include "useful/keyboard.h"
 
+/* * * * * * * * * * * * * * * * * * * * * * * * *\
+#                   METHODS                       #
+\* * * * * * * * * * * * * * * * * * * * * * * * */
 Task1::Task1(uint32_t magic, const ::Multiboot_Info* mbi)
             : Application(), magic(magic), mbi(reinterpret_cast<const Multiboot_Info*>(mbi)) {
   
diff -E -w -B --strip-trailing-cr -ruN --binary Aufgabe1_Lsg/src/user/task2.cc Aufgabe2/src/user/task2.cc
--- Aufgabe1_Lsg/src/user/task2.cc	1970-01-01 01:00:00.000000000 +0100
+++ Aufgabe2/src/user/task2.cc	2013-05-02 02:23:09.947629000 +0200
@@ -0,0 +1,55 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
+ *                                 Technische Informatik II                                      *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *                                                                                               *
+ *                                       T A S K 2                                               *
+ *                                                                                               *
+\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#include "user/task2.h"
+
+#include "useful/kout.h"
+#include "useful/keyboard.h"
+#include "useful/cpu.h"
+
+Task2::Task2(){
+  kout.setpos(31,1);
+  kout << "OOStuBs - Task 2" << endl << endl;
+  
+  keyboard.plugin();
+  cpu.enable_int();
+}
+
+Task2::~Task2(){
+  
+  cpu.disable_int();
+}
+
+void Task2::action(){
+  unsigned short x,y;
+  unsigned char i=0;
+  
+  kout.getpos(x,y);
+  while(1){
+    kout.setpos(x,y);
+    for(unsigned short j=0;j<39;j++){
+      kout << "-";
+    }
+    kout.flush();
+    
+    switch(i++%4)    {
+      case(0): kout << "//";
+           break;
+      case(1): kout << "--";
+           break;
+      case(2): kout << "\\\\";
+           break;
+      case(3): kout << "||";
+           break;
+    }
+    for(unsigned short j=0;j<39;j++){
+      kout << "-";
+    }
+    kout << endl;
+  }
+}
