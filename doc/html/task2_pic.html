<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OOStuBS - Technische Informatik II (TI-II): Informationen zum Programmierbaren Interrupt Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OOStuBS - Technische Informatik II (TI-II)
   &#160;<span id="projectnumber">2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li class="current"><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li><a href="annotated.html"><span>Klassen</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="task2.html">Aufgabe 2 - Interrupts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Informationen zum Programmierbaren Interrupt Controller </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Inhaltsverzeichnis</h3>
<ul><li class="level1"><a href="#task2_pic_sec1">Grundlagen</a><ul><li class="level2"><a href="#task2_pic_sec1_1">Regiester</a><ul><li class="level3"><a href="#task2_pic_sec1_1_1">Interrupt-Request Register (IRR)</a></li>
<li class="level3"><a href="#task2_pic_sec1_1_2">Interrupt-Service Register (ISR)</a></li>
<li class="level3"><a href="#task2_pic_sec1_1_3">Interrupt-Mask Register (IMR)</a></li>
</ul>
</li>
<li class="level2"><a href="#task2_pic_sec1_2">Master-Slave-System</a></li>
</ul>
</li>
<li class="level1"><a href="#task2_pic_sec2">Software</a><ul><li class="level2"><a href="#task2_pic_sec2_1">Ignorieren eines Interrupts</a></li>
<li class="level2"><a href="#task2_pic_sec2_2">Software zur Interruptbehandlung</a></li>
<li class="level2"><a href="#task2_pic_sec2_3">Zugriff auf die PICs über Ports</a></li>
</ul>
</li>
<li class="level1"><a href="#task2_pic_sec3">Literatur</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="task2_pic_sec1"></a>
Grundlagen</h1>
<p>Der PIC 8259A ist ein Chip - meist nur Teil eines Chips- der wie der Prozessor selbst auf dem Motherboard eines jeden PCs zu finden ist. Seine Aufgabe besteht in der Koordination der Unterbrechungsanforderungen der verschiedenen Geräte.</p>
<p>Dazu besitzt der PIC acht Eingänge <code>IR0</code> bis <code>IR7</code>, an die jeweils der Interruptausgang eines Gerätes angeschlossen werden kann. Beispiele für diese Geräte sind der Timer, die Tastatur, die seriellen Schnittstellen (Maus) und der Festplattencontroller. Die Nummer des IR Pins gibt gleichzeitig die Priorität der Unterbrechung an. Das Gerät, das an IR0 angeschlossen ist, wird mit höchster Priorität behandelt, das an <code>IR7</code> mit der niedrigsten.</p>
<p>Der PIC hat mehrere Ausgänge, durch die er mit der CPU verbunden ist. Unter anderem ist der Pin INT des PICs direkt an den Pin <code>INTR</code> der CPU angeschlossen, ebenso sind die bei PIC und CPU gleichermaßen mit <code>INTA</code> bezeichneten Pins gekoppelt. Die Pins <code>D0</code> bis <code>D7</code> des PICs sind mit den acht niederwertigsten Leiterbahnen des Datenbusses verbunden.</p>
<p>Wenn der PIC feststellt, dass auf mindestens einem seiner Eingänge <code>IR0</code> bis <code>IR7</code> eine Interruptanforderung anliegt und dem PIC nicht mitgeteilt wurde, dass er die entsprechende Anforderung ignorieren soll, so gibt er die Interruptanforderung über seinen Ausgang <code>INTR</code> an die CPU weiter. Diese wird die Anforderung mit Hilfe der <code>INTA</code> Leitung quittieren und durch ein zweites Signal auf <code>INTA</code> nach der Nummer des Interrupts fragen. Der PIC antwortet daraufhin, indem er die Nummer des Interrupts (gleich der Nummer der Eingangsleitung + einem Offset) auf den Datenbus legt. Die CPU ist nun in der Lage, die Anfangsadresse der Unterbrechungsbehandlungsroutine zu finden und die Unterbrechungsbehandlung zu starten.</p>
<h2><a class="anchor" id="task2_pic_sec1_1"></a>
Regiester</h2>
<p>Damit der PIC sich merken kann, von welchen Geräten er Interruptanforderungen erhalten hat, welche er ignorieren soll und welche gerade von der CPU behandelt werden, besitzt er drei interne Register, die jeweils acht Bit breit sind.</p>
<h3><a class="anchor" id="task2_pic_sec1_1_1"></a>
Interrupt-Request Register (IRR)</h3>
<p>Hier speichert der PIC, auf welchen der IR Leitungen eine Interruptanforderung signalisiert wurden. Dadurch braucht das betreffende Gerät nur eine kurze Änderung des Pegels auf der Leitung auszulösen.</p>
<h3><a class="anchor" id="task2_pic_sec1_1_2"></a>
Interrupt-Service Register (ISR)</h3>
<p>Liegen die Interruptanforderungen mehrerer Geräte gleichzeitig an, so wird der PIC zunächst nur die wichtigste weiterleiten. Dazu wird die Unterbrechungsanforderung der CPU über die Leitung <code>INT</code> angezeigt. Sobald diese daraufhin mit zwei INTA Signalen reagiert hat, wird nicht nur die Nummer des Interrupts auf den Datenleitungen <code>D0</code> bis <code>D7</code> ausgegeben, sondern auch das entsprechende Bit im <code>ISR</code> gesetzt. Gleichzeitig wird das Bit im <code>IRR</code> gelöscht. Da das Bit im <code>ISR</code> gesetzt bleibt, bis es von der Unterbrechungsbehandlungsroutine mit Hilfe eines speziellen Befehls explizit gelöscht wird, kann der PIC beim Eintreffen einer weiteren Unterbrechung leicht erkennen, ob diese noch wichtiger als die gerade bearbeitete ist. In diesem Fall wird er dies der CPU durch ein erneutes Signal auf der <code>INT</code> Leitung mitteilen.</p>
<h3><a class="anchor" id="task2_pic_sec1_1_3"></a>
Interrupt-Mask Register (IMR)</h3>
<p>Mit Hilfe dieses Registers ist es möglich, Interrupts selektiv zu unterdrücken. Ein gesetztes Bit im IMR sorgt dafür, dass der PIC Interrupts des entsprechenden Gerätes ignoriert.</p>
<h2><a class="anchor" id="task2_pic_sec1_2"></a>
Master-Slave-System</h2>
<p>Um mehr als acht Interruptquellen unterscheiden zu können, enthalten moderne PCs - das heißt alle ab dem XT von 1983 - zwei PICs, die hintereinander geschaltet sind. Der <code>INT</code> Ausgang des Slave-PICs hat also keine direkte Verbindung zu dem <code>INTR</code> Eingang der CPU, sondern wird an einen der IR Einänge (IR2) des Master PICs angeschlossen. Außerdem stehen Master und Slave über drei weitere Leitungen in Verbindungen, über die der Master dem Slave mitteilen kann, wann dieser die Nummer des von ihm signalisierten Interrupts auf den Datenbus legen soll.</p>
<p>OOStuBS implementiert das Master-Slave in der Klasse <a class="el" href="classPIC.html">PIC</a>.</p>
<p>Mittlerweile wird der <code>APIC</code> - Advanced Programmable Interrupt Controller - verwendet. Mit diesem ist ein Mehrkern- und Mehrprozessorbetrieb möglich. OOStuBS verwendet diesen allerdings nicht. Das Grundprinzip kann nach wie vor mit dem einfacher zu bedienenden PIC verdeutlicht werden.</p>
<h1><a class="anchor" id="task2_pic_sec2"></a>
Software</h1>
<h2><a class="anchor" id="task2_pic_sec2_1"></a>
Ignorieren eines Interrupts</h2>
<p>CPU-seitig kann dafür gesorgt werden, dass das laufende Programm nicht durch Interrupts unterbrochen wird. Dazu wird mit der Assembleranweisung <code>cli</code> das Interrupt-Bit im <code>EFLAGS</code> -Register gelöscht. Der Prozessor wird auf Signale seiner <code>INTR</code> Leitung nun nicht mehr reagieren. Da der PIC einen Interrupt frühestens dann weitergibt, wenn die CPU auf den vorhergehenden Interrupt reagiert hat, wird der PIC keine Interrupts weiterleiten, solange die CPU Interrupts ignoriert. <br/>
 Dieser Vorgang kann mit dem Befehl <code>sti</code> wieder rückgängig gemacht werden.</p>
<p>Interrupts können auch selektiv unterdrückt werden. Dazu muss der PIC programmiert werden. Das geht wie üblich mit <code>in</code> und <code>out</code> Befehlen.</p>
<h2><a class="anchor" id="task2_pic_sec2_2"></a>
Software zur Interruptbehandlung</h2>
<p>Wenn ein Interrupt ankommt, der sowohl seitens des PICs als auch seitens der CPU zugelassen wurde, verzweigt der Prozessor automatisch zur Interruptbehandlungsroutine.</p>
<p>Deren Adresse wird einer Interruptdeskriptortabelle (<code>IDT</code>) entnommen, wobei die von dem PIC auf den Datenbus gelegte Nummer des Interrupts als Index dient. Beim 8086 Prozessor war die Lage der Interruptdeskriptortabelle noch fest von der Hardware vorgegeben, ab dem 80386 wird ihr Anfang und ihre Größe durch das IDT-Register beschrieben.</p>
<p>Die Interruptdeskriptortabelle kann maximal 256 Interruptgate-Deskriptoren enthalten, von denen es drei verschiedene Typen gibt </p>
<ul>
<li><b>Task-Gate</b><br/>
 Der Taskgate-Deskriptor zeigt auf einen Task, einen hardwaremäßig unterstützten Prozeß. Wenn der entsprechende Interrupt eintritt, führt der Prozessor automatisch einen Taskwechsel zu dem angegebenen Interrupt-Task durch. </li>
<li><b>Interrupt-Gate</b><br/>
 Der Interruptgate-Deskriptor zeigt auf eine Prozedur, die als Interruptbehandlungsroutine ohne vorherigen Taskwechsel aufgerufen wird. </li>
<li><b>Trap-Gate</b><br/>
 Der Trapgate-Deskriptor zeigt auf eine Prozedur, die als Trapbehandlungsroutine ohne vorherigen Taskwechsel aufgerufen wird.</li>
</ul>
<p>Bevor der Prozessor infolge eines Interrupts oder Traps die angegebene Behandlungsroutine aufruft, legt er den aktuellen Inhalt des <code>EFLAGS</code> -Registers auf den Stack ab. Dies ermöglicht es ihm, nun das Interrupt-Enable-Flag im <code>EFLAGS</code> -Register zu löschen und auf diese Weise die geschachtelte Behandlung weiterer Interrupts zu verhindern. Wie bei einem normalen Funktionsaufruf wird dann noch die Rücksprungadresse - Inhalt von Code-Segment und Instruction Pointer - auf dem Stack gesichert, bevor die Behandlungsroutine begonnen wird. <br/>
 Bei manchen Exceptions legt der Prozessor zusätzlich einen Fehlercode auf dem Stack ab.</p>
<p>Wurde die Unterbrechung durch einen Interrupt ausgelöst, besteht eine Aufgabe der Interruptbehandlungsroutine darin, dem PIC mitzuteilen, dass der Interrupt behandelt wurde. Anderenfalls wird der PIC nämlich keine weiteren Interrupts desselben Gerätes weiterleiten. Das Senden dieses Interrupt-Acknowledge-Signals erfolgt wieder mit einem bzw. bei einer Kaskadierung der PICs mit zwei out Befehlen an den Port des PICs.</p>
<p>Mit dem <code>iret</code> Befehl wird die Unterbrechungsbehandlung abgeschlossen. Der Prozessor holt die Rücksprungadresse vom Stack, stellt den Inhalt des <code>EFLAGS</code> -Registers wieder her und kehrt zu der unterbrochenen Methode zurück. Dadurch, dass auch die <code>EFLAGS</code> wieder hergestellt werden, werden spätestens jetzt die Interrupts CPU-seitig wieder zugelassen.</p>
<h2><a class="anchor" id="task2_pic_sec2_3"></a>
Zugriff auf die PICs über Ports</h2>
<p>Jedem der beiden PICs in einem PC sind zwei Ports im I/O-Adressraum zugeordnet, die wie folgt belegt sind: </p>
<table  rules="all" border="1">
<tr>
<th><b>Port</b>(IRQ0-7/IRQ8-15)</th><th><b>Lesedaten</b></th><th><b>Schreibdaten</b> </th></tr>
<tr>
<td>0x20 / 0xa0</td><td>IRR, ISR, Int.Vektor</td><td>ICW1, OCW2, OCW3 </td></tr>
<tr>
<td>0x21 / 0xa1</td><td>IMR</td><td>ICW2, ICW3, ICW4, OCW1 </td></tr>
</table>
<p>Die Bezeichnungen <code>ICW</code> und <code>OCW</code> stehend dabei für Initialization Control Word und Operation Control Word. Für die Lösung der Aufgabe sind nur die Operationsbefehlsworte <code>OCW1</code> und <code>OCW2</code> relevant: </p>
<ul>
<li><code>OCW1</code> ist schlicht ein Platzhalter für die Maske der gesperrten Interrupts. Diese Maske wird direkt in das Interrupt Mask Register (<code>IMR</code>, <code>0x21/0xa1</code>) übertragen; ein gesetztes Bit X sorgt dafür, dass der entsprechende Interrupt X gesperrt wird. </li>
<li><code>OCW2</code> wird verwendet um dem PIC einen <code>EOI</code> -Befehl zu senden, damit dieser erfährt, dass der Interrupt bearbeitet wird und das gesetzte Bit im <code>ISR</code> löscht. Bei OOStuBS verwenden wir den "unspezifischen \c EOI -Befehl": <code>OCW2</code> == <code>0x20</code> wird nach der Bearbeitung eines Interrupts in die Kontrollregister <code>0x20/0xa0</code> geschrieben.</li>
</ul>
<p>Die Initialisierungsbefehlsworte <code>ICW1</code> bis <code>ICW4</code> dienen der Initialisierung des Chips. Dies erfolgt bei OOStuBS innerhalb des Konstruktors des PIC, so dass ihr euch darum ausnahmsweise mal nicht selber kümmern müsst.</p>
<h1><a class="anchor" id="task2_pic_sec3"></a>
Literatur</h1>
<ul>
<li><a href="http://www.lowlevel.eu/wiki/Programmable_Interrupt_Controller">PIC auf lowlevel.eu</a> </li>
<li><a href="http://wiki.osdev.org/8259_PIC">8259 PIC auf osdev.org</a> </li>
<li>Hans-Peter Messmer, "PC-Hardwarebuch", Addison-Wesley, 1995 </li>
<li>Intel, "8259A - Programmable Interrupt Controller" </li>
<li>Andreas Roth, "Das Computer-Peripherie Kochbuch", IWT Verlag, 1990 </li>
<li>Klaus-Dieter Thies, "80386 - Die innovativen 80286/80386 Architekturen", tewi Verlag, 1988 </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Mai 29 2013 23:52:16 für OOStuBS - Technische Informatik II (TI-II) von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
