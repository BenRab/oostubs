<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OOStuBS - Technische Informatik II (TI-II): Task 4 - Threads</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">OOStuBS - Technische Informatik II (TI-II)
   &#160;<span id="projectnumber">2.4</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Task 4 - Threads </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Diese Aufgabe basiert auf einem neuen Grundsystem. Dieses läuft nicht mehr Dieses läuft nicht mehr als eigenständiges Betriebssystem, sondern als normales Programm unter Linux. Zur Nutzung ist eine neue Vorgabe herunter zu laden. <br/>
</p>
<p>Das Ziel dieser Aufgabe ist die Vermittelung eines der wichtigsten Abstraktionen moderner Betriebssysteme: Threads und deren Scheduling. Die Aufgabe ist in 2 Unteraufgaben unterteilt:</p>
<h2><a class="anchor" id="task4_a"></a>
Aufgabe A - Kooperative Scheduling</h2>
<p>Diese Aufgabe befasst sich mit kooperativen Scheduling. Daher muss jeder <a class="el" href="classThread.html" title="Basic multitasking entity.">Thread</a> individuell die Aktivität an andere Threads übergeben, es findet kein externes Scheduling statt.</p>
<p>Die Klasse <a class="el" href="classTask4.html">Task4</a> initialisiert in <a class="el" href="classTask4.html#a2a7d07836599ad51be274201cf6c2027">Task4::action</a> zum Testen der entsprechenden Funktionen drei Applikationen <a class="el" href="classTask4.html#ad6e7cc1812f40f907d3d87344a6591ab">Task4::counter1</a>, <a class="el" href="classTask4.html#a632d839a7057fc3e73382faef25d4037">Task4::counter2</a> und <a class="el" href="classTask4.html#aa684b9f23471531af0eb951ba8809b67">Task4::rotCursor</a>. Diese Threads werden in <a class="el" href="classTask4.html#a2a7d07836599ad51be274201cf6c2027">Task4::action</a> dem <a class="el" href="classScheduler.html" title="Basic Scheduler.">Scheduler</a> als bereite Threads übergeben (Funktion <a class="el" href="classScheduler.html#a01502861acea705fd4b34590b257c354">Scheduler::ready</a>). Die verschiedenen Applikationen erben alle von <a class="el" href="classThread.html">Thread</a> der damit die Grundlage für jede Applikation übernimmt <a class="el" href="classApplication.html">Application</a>.</p>
<p>Der Scheudler legt die Anwendungen in seiner Ready-Queue ab, die dann sequentiell durchlaufen wird. Wir verwenden dafür den STL-Container Deque <a class="el" href="classScheduler.html#a07562b9fa3f140d4b99b500a457d90cd">Scheduler::threads</a> der bereits im Header File angelegt ist.</p>
<p>Das Umschalten zwischen den verschiedenen Threads geschit durch die <a class="el" href="classScheduler.html" title="Basic Scheduler.">Scheduler</a> Funktion <a class="el" href="classScheduler.html#aa4da1861292d77ea37cfa90b6ad569f3">Scheduler::resume</a> oder <a class="el" href="classScheduler.html#a7648753bdb11886d5d8ae560b7d0e52b">Scheduler::exit</a>. Diese sind zur leichter Benutzbarkeit als Forwarding-Funktionen in <a class="el" href="classThread.html">Thread</a> bereits vorgesehen.</p>
<p>Der eiegntliche Kontextwechsel wird dann durch den <a class="el" href="classDispatcher.html">Dispatcher</a> vorgenommen. Dieser soll hierfür die Linux Context Funktionen nutzen (getcontext, setcontext, makecontext, swapcontext). Weitere Informationen zu diesen Funktionen findet ihr in den entsprechenden man-Pages.</p>
<p>Das Starten des ersten Threads des Systems, <a class="el" href="classTask4.html" title="Fourth test application.">Task4</a> selber, geschieht über eine spezielle <a class="el" href="classScheduler.html" title="Basic Scheduler.">Scheduler</a> Funktion <a class="el" href="classScheduler.html#a45442044c5cb2151b00f507a3c8d8195">Scheduler::schedule</a>. Diese Funktion wird am Ende von <a class="el" href="main_8cc.html#aadb4d5397feda84ee5ee39b33082faca">kernel</a> aufgerufen und kehrt nie zurück!</p>
<h3><a class="anchor" id="task4_a_steps"></a>
Vorgehen</h3>
<ul>
<li>Recherchieren sie die Methoden (getcontext, setcontext, makecontext, swapcontext).</li>
</ul>
<ul>
<li>Implementieren sie die Methode <a class="el" href="classScheduler.html#a45442044c5cb2151b00f507a3c8d8195">Scheduler::schedule</a> mit allen Abhänigkeiten des Dispatchers.</li>
</ul>
<ul>
<li>Verifizieren sie den initialen Kontextwechsel durch Ausgaben in <a class="el" href="classTask4.html#a2a7d07836599ad51be274201cf6c2027" title="start operation">Task4::action</a></li>
</ul>
<ul>
<li>Recherchieren Sie die Methoden des Deque Containers.</li>
</ul>
<ul>
<li>Implementieren Sie <a class="el" href="classScheduler.html#a01502861acea705fd4b34590b257c354">Scheduler::ready</a>, um Tasks in der Queue abzulegen.</li>
</ul>
<ul>
<li>Implementieren Sie <a class="el" href="classScheduler.html#aa4da1861292d77ea37cfa90b6ad569f3">Scheduler::resume</a>, die den neuen Task läd und den alten in der Queue abspeichert. Zudem muss der <a class="el" href="classDispatcher.html" title="Managing currently active threads.">Dispatcher</a> aufgerufen werden <a class="el" href="classDispatcher.html#ae5e8e2d148cd30aa060cab3c410396d1">Dispatcher::dispatch</a></li>
</ul>
<ul>
<li>Füllen Sie die Methode <a class="el" href="classScheduler.html#a7648753bdb11886d5d8ae560b7d0e52b">Scheduler::exit</a> (Beenden und Löschen des aktuellen Threads) und <a class="el" href="classScheduler.html#a7301daa452a49c955534a11741634c8d">Scheduler::kill</a> (Löschen eines nicht-aktiven Threads) mit Ihrem Code.</li>
</ul>
<h2><a class="anchor" id="task4_b"></a>
Aufgabe B - Preemptives Scheduling</h2>
<p>Preemtives Scheduling erweitert das kooperative Scheduling um einen periodischen asynchronen Aufruf von <a class="el" href="classScheduler.html#aa4da1861292d77ea37cfa90b6ad569f3">Scheduler::resume</a>.</p>
<p>Hierdurch wird einerseits ein interaktiverer Betrieb ermöglicht, andererseits muss aber der Umschaltvorgang an sich geschützt werden um die Konsistenz der beteiligten Datenstrukturen sicherzustellen. In unserem Beispiel muss lediglich der Zugriff auf die Warteschlange als kritischer Abschnitt geschützt werden. Dazu wird eine Klasse <a class="el" href="classLock.html">Lock</a> bereitgestellt.</p>
<p>Objekte dieser Klasse erzeugen für die Dauer ihrer Lebenszeit eine kritischen Abschnitt. </p>
<div class="fragment"><pre class="fragment"> {
   <a class="code" href="classLock.html" title="Global interrupt lock.">Lock</a> lock;
   ...
 }
</pre></div><p>Dieses Code Fragment erzeugt eine kritischen Abschnitt inerhalb des durch geschweifte Klammern markierten Bereichs.</p>
<p>Der periodische Call zu <a class="el" href="classScheduler.html#aa4da1861292d77ea37cfa90b6ad569f3" title="Use the scheduling algorithm to get the next thread and resumes with that thread.">Scheduler::resume</a> wird durch einen emulierten Hardware-Timer zur Verfügung gestellt. Daher muss eine entsprechende Interuptbehandlung von Interrupt 0 durchgeführt werden, welcher alle <a class="el" href="boot_8cc.html#a4fdc24ca775b06ad17bbce2cf07cad31">rrTimeSlice</a> ausgelöst wird. Dafür soll die Klasse <a class="el" href="classWatch.html" title="Handler for periodic timer interrupts.">Watch</a> genutzt werden, deren Struktur dabei dem bekannten Aufbau eines <a class="el" href="classGate.html">Gate</a> Objektes folgt. Insebsondere umfasst sie zu implementierenden Methoden <a class="el" href="classWatch.html#a147c656850857b641537d7ca232f5aff">Watch::windup</a> (einhängen des Timers in der <a class="el" href="classPlugbox.html" title="Interrupt forwarding administration unit.">Plugbox</a>) und <a class="el" href="classWatch.html#a405dccf51f12ca5b5c5409add9a5a09f">Watch::trigger</a> (wird ausgeführt wenn eine Periode abgelaufen ist).</p>
<h3><a class="anchor" id="task4_b_steps"></a>
Vorgehen</h3>
<ul>
<li>Implementieren Sie die Methoden der Klasse <a class="el" href="classWatch.html" title="Handler for periodic timer interrupts.">Watch</a>. </li>
<li>Evaluieren sie die Richtigkeit durch periodische Textausgaben. </li>
<li>Sichern Sie die Zugriffe auf die Queue </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 9 2013 12:59:46 for OOStuBS - Technische Informatik II (TI-II) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
