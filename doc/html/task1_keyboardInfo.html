<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OOStuBS - Technische Informatik II (TI-II): Informationen zum Tastaturkontroller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OOStuBS - Technische Informatik II (TI-II)
   &#160;<span id="projectnumber">2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li class="current"><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li><a href="annotated.html"><span>Klassen</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="task1.html">Aufgabe 1 - Ausgabefunktionen und Tastatursteuerung</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Informationen zum Tastaturkontroller </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Inhaltsverzeichnis</h3>
<ul><li class="level1"><a href="#task1_keyboard_sec1">Zeichen- und Tastaturcodes</a><ul><li class="level2"><a href="#task1_keyboard_sec1_sub1">ASCII Code</a></li>
<li class="level2"><a href="#task1_keyboard_sec1_sub2">Scancode</a></li>
<li class="level2"><a href="#task1_keyboard_sec1_sub3">Make- und Breakcodes</a></li>
</ul>
</li>
<li class="level1"><a href="#task1_keyboard_sec2">Tastaturkontroller</a><ul><li class="level2"><a href="#task1_keyboard_sec2_sub1">Tastaturcontroller programmieren</a></li>
</ul>
</li>
<li class="level1"><a href="#task1_keyboard_sec3">Weiterführende Informationen und Referenzen</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="task1_keyboard_sec1"></a>
Zeichen- und Tastaturcodes</h1>
<p>Zur Programmierung des Tastaturkontrollers und der Verwendung von Tastaturabfragen sind verschiedene Codes von Bedeutung.</p>
<h2><a class="anchor" id="task1_keyboard_sec1_sub1"></a>
ASCII Code</h2>
<p>Zeichen und Zeichenketten werden üblicherweise im ASCII-Code abgespeichert. Der <b>American Standard Code for Information Interchange</b> ist eine in der Computerwelt sehr weit verbreitete Zuordnungstabelle für die Darstellung von Buchstaben, Ziffern und Sonderzeichen. Ursprünglich waren pro Zeichen 7 Bits vorgesehen, mittlerweile haben sich aber 8 Bits, also die Darstellung in einem Byte durchgesetzt.</p>
<h2><a class="anchor" id="task1_keyboard_sec1_sub2"></a>
Scancode</h2>
<p>Der Scancode ordnet den Tasten einer PC Tastatur eindeutige Nummern zu. Dadurch ist es auch möglich Tasten zu identifizieren, die keinem druckbaren Zeichen entsprechen (z.B. Cursortasten). Bei der Verwendung von Scancodes ist darauf zu achten, dass nicht zwischen Groß- und Kleinbuchstaben unterschieden wird, da beide mit derselben Taste erreicht werden (Groß- und Kleinschreibung ergibt sich aus der Kombination des Scancodes mit den Make- und Breakcodes). Im Laufe der PC Entwicklungsgeschichte wurden unterschiedliche Tastaturen mit einer unterschiedlichen Anzahl und Bedeutung von Tasten herausgebracht. Gerade bei den Funktions- und Spezialtasten gibt es daher auch unterschiedliche Scancodes. Da PC Tastaturen jedoch nur wenig mehr als 100 Tasten besitzen, genügen 7 Bits, um den Scancode einer PC Tastatur darzustellen.</p>
<h2><a class="anchor" id="task1_keyboard_sec1_sub3"></a>
Make- und Breakcodes</h2>
<p>Programme müssen nicht nur feststellen können, welche der normalen Tasten gedrückt wurden, sondern auch, ob gleichzeitig die Shift (Umschalt)-Taste, die Control (Steuerungs)-Taste oder die ALT-Taste festgehalten wurden. Daher sendet die Tastatur statt eines einfachen Scancodes einen oder mehrere sogenannte Makecodes für jedes Drücken und einen oder mehrere Breakcodes für jedes Loslassen einer Taste. Wenn eine Taste länger als eine bestimmte Zeitspanne festgehalten wird, werden darüberhinaus zusätzliche Makecodes gesendet, durch die die Wiederholungsfunktion realisiert wird. Bei den meisten Tasten entspricht sowohl der Makecode als auch der Breakcode dem Scancode mit gesetztem 7. Bit. Einige Tasten erzeugen jedoch aus historischen Gründen schon beim einmaligen Drücken und Loslassen mehrere Make- und Breakcodes. Der Tastaturtreiber (siehe <a class="el" href="classKeyboard__Controller.html#aa517065c0ed4059b477dfb481539b1b2">Keyboard_Controller::key_decoded</a>) muss aus den Make- und Breakcodes der gedrückten Tasten die gewünschten Zeichen ermitteln.</p>
<dl class="section attention"><dt>Achtung</dt><dd>Da die Interpretation der Make- und Breakcodes ziemlich mühsam, langweilig und wenig lehrreich ist, haben wir euch die Dekodierung bereits abgenommen. Es kann allerdings sein, dass diese Funktion bei eurer Tastatur nicht alle Zeichen, insbesondere die deutschen Umlaute korrekt erkennt. In diesem Fall müsst ihr entweder mit ein paar falschen Zeichen leben oder die Tabellen der Dekodierfunktion entsprechend anpassen.</dd></dl>
<h1><a class="anchor" id="task1_keyboard_sec2"></a>
Tastaturkontroller</h1>
<p>Wenn bei einer PC-Tastatur eine Taste gedrückt wird, werden zwei sich kreuzende Leitungen der Scan-Matrix innerhalb der Tastatur verbunden. Der Tastaturprozessor (8042 für PC/XT-, 8048 für AT und MF II-Tastaturen) ermittelt die Position der gedrückten Taste und daraus den Scancode. Über eine serielle Schnittstelle wird der Code dann zum Motherboard des PCs gesendet. Auf dem Motherboard des PCs befindet sich ein Tastaturcontroller, der einerseits über einen Eingabe- und einen Ausgabeport mit der Tastatur kommuniziert (Tastaturkommandos). Andererseits verwendet der Kontroller Register, die mit Hilfe von in und out-Befehlen über den Systembus gelesen und beschrieben werden können. </p>
<table  rules="all" border="1">
<tr>
<td><b>Port</b></td><td><b>R / W</b></td><td><b>Register</b></td><td><b>Bedeutung</b> </td></tr>
<tr>
<td>0x60</td><td>R</td><td>Ausgabepuffer</td><td>Make/Breakcode von der Tastatur </td></tr>
<tr>
<td>0x60</td><td>W</td><td>Eingabepuffer</td><td>Befehle für die Tastatur (<em>z.B. LEDs setzen</em>) </td></tr>
<tr>
<td>0x64</td><td>W</td><td>Steuerregister</td><td>Befehle für den Tastaturcontroller </td></tr>
<tr>
<td>0x64</td><td>R</td><td>Statusregister</td><td>Zustand des Tastaturcontrollers (z.B. Ausgabepuffer voll?) </td></tr>
</table>
<p><br/>
</p>
<p>Das Schreiben eines Bytes vom Tastaturontroller in seinen Ausgabepuffer wird immer durch das Setzen einer Interruptanforderung signalisiert. Auf diese Anforderung reagiert der Prozessor, indem er das ankommende Byte aus dem Ausgabepuffer ausliest und im Statusregister vermerkt, dass der Ausgabepuffer wieder leer ist. Erst jetzt können neue Zeichen von der Tastatur entgegengenommen werden. Wird die Tastatur im Pollingbetrieb benutzt, kann durch Bit 0 überprüft werden, ob sich auch tatsächlich ein Zeichen im Ausgabepuffer des Tastaturcontrollers befinden. Soll ein Byte an den Kontroller geschickt werden (z.B. Tastaturkommando), muss immer gewartet werden, bis der Eingabepuffer des Kontrollers leer ist (Bit 1 gelöscht), bevor der Buffer erneut beschrieben werden kann.</p>
<p>Beachtet werden sollte, dass bei PS/2 PCs die Maus ebenfalls an den Tastaturkontroller angeschlossen ist. Dadurch landen sowohl die Codes der Tastatur als auch die der Maus im Ausgabepuffer. Damit die Quelle der Codes unterschieden werden kann, steht im Statusregister das <b>Bit 5</b> (AUXB) zur Verfügung (1 = Maus, 0 = Tastatur).</p>
<table  rules="all" border="1">
<tr>
<td><b>Bit</b></td><td><b>Maske</b></td><td><b>Name</b></td><td><b>Bedeutung</b> </td></tr>
<tr>
<td>0</td><td>0x01</td><td>outb</td><td>Gesetzt, wenn ein Zeichen im Ausgabepuffer des Tastaturcontrollers zum Lesen bereit steht </td></tr>
<tr>
<td>1</td><td>0x02</td><td>inpb</td><td>Gesetzt, solange der Tastaturcontroller ein von der CPU geschriebenes Zeichen noch nicht abgeholt hat </td></tr>
<tr>
<td>5</td><td>0x20</td><td>auxb</td><td>Gesetzt, wenn der Wert im Ausgabepuffer von der Maus und nicht von der Tastatur stammt </td></tr>
</table>
<h2><a class="anchor" id="task1_keyboard_sec2_sub1"></a>
Tastaturcontroller programmieren</h2>
<p>Der Tastaturcontroller kann durch das Senden von Befehlscodes an den Eingabepuffer konfiguriert werden. Zuvor sollte man jedoch sicherstellen, das der Eingabepuffer des Tastaturcontrollers leer ist (inpb). Danach wird der Befehlscode (siehe Tabelle) in den Datenport geschrieben. Danach sollte man warten, bis der Tastaturcontroller geantwortet hat und der Ausgabepuffer das Bestätigungsbyte <code>0xfa</code> (ACK) enthält (wieder vor dem Lesen outb prüfen). Wir werden von den etwa 20 Befehlen, die der Tastaturcontroller versteht, nur zwei verwenden:</p>
<table  rules="all" border="1">
<tr>
<td><b>Befehl</b></td><td><b>Steuercode</b> </td></tr>
<tr>
<td>set_led</td><td><code>0xed</code> </td></tr>
<tr>
<td>set_speed</td><td><code>0xf3</code> </td></tr>
</table>
<p>Die folgende Tabelle zeigt den Aufbau des Steuerbytes von set_led zum Ansteuern der Tastatur-LEDs. <b>MSB</b> bedeutet hierbei most significant bit (entspricht also <code>0x80</code> in Hexadezimal-Darstellung) und <b>LSB</b> least significant bit (also <code>0x01</code>).</p>
<table  rules="all" border="1">
<tr>
<td><b>MSB</b></td><td></td><td></td><td></td><td></td><td></td><td></td><td><b>LSB</b> </td></tr>
<tr>
<td>Always 0</td><td>Always 0</td><td>Always 0</td><td>Always 0</td><td>Always 0</td><td>Caps Lock</td><td>Num Lock</td><td>Scroll Lock </td></tr>
</table>
<p>Der Aufbau des Konfigurationsbyte von set_speed ist in diesen zwei Tabellen beschrieben. Die Wiederholungsrate wird durch die Bits 0-4 spezifiziert, die Verzögerung durch Bit 5 und 6.</p>
<table  rules="all" border="1">
<tr>
<td><b>Bits 0-4 (hex)</b></td><td><b>Wiederholungsrate (Zeichen pro Sekunde)</b> </td></tr>
<tr>
<td>0x00</td><td>30 </td></tr>
<tr>
<td>0x02</td><td>25 </td></tr>
<tr>
<td>0x04</td><td>20 </td></tr>
<tr>
<td>0x08</td><td>15 </td></tr>
<tr>
<td>0x0c</td><td>10 </td></tr>
<tr>
<td>0x10</td><td>7 </td></tr>
<tr>
<td>0x14</td><td>5 </td></tr>
<tr>
<td><b>Bits 5 und 6 (hex)</b></td><td><b>Verzögerung (in Sekunden)</b> </td></tr>
<tr>
<td>0x00</td><td>0.25 </td></tr>
<tr>
<td>0x01</td><td>0.5 </td></tr>
<tr>
<td>0x02</td><td>0.75 </td></tr>
<tr>
<td>0x03</td><td>1.0 </td></tr>
</table>
<h1><a class="anchor" id="task1_keyboard_sec3"></a>
Weiterführende Informationen und Referenzen</h1>
<ul>
<li>Messmer, Hans Peter: PC-Hardwarebuch - Aufbau, Funktionsweise, Programmierung., Addison-Wesley, 1994</li>
<li>The AT keyboard controller</li>
<li><a href="http://wiki.osdev.org/%228042%22_PS/2_Controller">"8042" PS/2 Controller</a> auf osdev.org</li>
<li><a href="http://www.lowlevel.eu/wiki/Keyboard_Controller">Keyboard Controller</a> auf lowlevel.eu </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Mon Mai 20 2013 12:56:28 für OOStuBS - Technische Informatik II (TI-II) von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
